<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Louis Li]]></title>
  <link href="http://louisrli.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://louisrli.github.io/"/>
  <updated>2023-02-10T23:28:31+01:00</updated>
  <id>http://louisrli.github.io/</id>
  <author>
    <name><![CDATA[Louis Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The TypeScript Web Protobuf Environment in 2023]]></title>
    <link href="http://louisrli.github.io/blog/2023/02/10/navigating-the-open-source-protobuf-environment-in-2023/"/>
    <updated>2023-02-10 00:00:00 +0100</updated>
    <id>http://louisrli.github.io/blog/2023/02/10/navigating-the-open-source-protobuf-environment-in-2023</id>
    <content type="html"><![CDATA[<p>Another title of this post would be: for protocol buffers in web clients, which
TypeScript protocol buffer libraries are well-documented, and which ones are
badly documented?</p>

<p>In this post, I’ll talk about the mess that’s the open source TypeScript
protocol buffer ecosystem. For historical reasons, based on various libraries
that were released when others didn’t exist, there are some libraries that work
with each other, some that are outdated, etc. In general, this happens quite
commonly in the open source ecosystem, and I hope this post helps others.</p>

<p>The TLDR, if you want to use protocol buffers with the browser:</p>

<ul>
  <li>Use <a href="https://github.com/timostamm/protobuf-ts"><code class="language-plaintext highlighter-rouge">protobuf-ts</code></a> and
 <a href="https://github.com/grpc/grpc-web"><code class="language-plaintext highlighter-rouge">grpc/grpc-web</code></a></li>
  <li>Do <strong>NOT</strong> use <a href="https://github.com/stephenh/ts-proto"><code class="language-plaintext highlighter-rouge">ts-proto</code></a> or <a href="https://github.com/improbable-eng/grpc-web"><code class="language-plaintext highlighter-rouge">improbable-eng/grpc-web</code></a></li>
</ul>

<!-- more -->

<p>My recommendations don’t even have to do with the functionality necessarily;
<strong>they’re about the documentation</strong>. Note that documentation doesn’t
just mean READMEs but also code examples, which are notably missing from the
ones that I suggest not to use.</p>

<p>One disclaimer: perhaps for other side use cases those 
libraries are well-documented. For the particular use case of web RPCs,
they are lacking.</p>

<p>The rest of the post is mostly an explanation of my findings of the current
state of TypeScript protobuf tools. If you just want to know which tools to
use, trust me on the TLDR, and skip the rest of the post.</p>

<h2 id="context">Context</h2>

<p>I wanted to make a simple demo of a TypeScript React client connecting to a
TypeScript Node backend.</p>

<p>I used to work at Google for four years, and like
everyone who’s worked at Google (there’s even a derisive term “proto pusher” to
sometimes the mindless work of protos), I’ve used protocol buffers extensively. I’m not
claiming to be the world’s foremost expert on protocol buffers or that I should
be able to understand anything about protos instantly, but I just want to make
the point: I’ve used them to set up web flows, data pipelines, clients and
servers from scratch, etc. With a foundational knowledge of
protobufs and how they’re transmitted, I should, in theory, be able to find some
documentation and set up a basic “Hello World” RPC quickly.</p>

<p>Of course, documentation is different inside and outside of Google, but that’s
the point of this post. Given the wild environment of various solutions created
at various times, I hope to provide an explanation of what works (until this
post becomes outdated, of course).</p>

<p>In short: after spending five hours desperately searching for documentation to
use the combination I said not to use (which have higher number of stars on
GitHub), I set up a working end-to-end connection in 20 minutes using the
combination that I said to use (<code class="language-plaintext highlighter-rouge">grpc/grpc-web</code> and <code class="language-plaintext highlighter-rouge">protobuf-ts</code>) because of <strong>good
documentation</strong>.</p>

<h2 id="points-of-confusion">Points of confusion</h2>

<h3 id="type-generation">Type generation</h3>

<p>You have protocol buffers, which define a contract for entities that you want to
work with. Now you want to generate Typescript types from those protos.</p>

<p>As far as I can tell, there exist two main open source options for type
generation:</p>

<ul>
  <li><a href="https://github.com/stephenh/ts-proto"><code class="language-plaintext highlighter-rouge">ts-proto</code></a> (has more stars)</li>
  <li><a href="https://github.com/timostamm/protobuf-ts"><code class="language-plaintext highlighter-rouge">protobuf-ts</code></a></li>
</ul>

<p>I think there’s also now TypeScript generation built into the official <code class="language-plaintext highlighter-rouge">protoc</code>,
but again, the documentation in this world is so obfuscated that I only figured
that out from reading <code class="language-plaintext highlighter-rouge">grpc/grpc-web</code> example code five directories deep in the
repository.</p>

<p><code class="language-plaintext highlighter-rouge">protobuf-ts</code> is the clear winner here, simply because of
<a href="[https://github.com/timostamm/protobuf-ts/blob/master/MANUAL.md](https://github.com/timostamm/protobuf-ts/blob/master/MANUAL.md)"><code class="language-plaintext highlighter-rouge">MANUAL.md</code></a>.
The <code class="language-plaintext highlighter-rouge">MANUAL.md</code> , while quite long, has stellar examples for use cases on both
the client- and server- sides. On top of that, there is a <strong>whole folder</strong> of
<a href="https://github.com/timostamm/protobuf-ts/tree/master/packages">actual code examples</a>,
while <code class="language-plaintext highlighter-rouge">ts-proto</code>, from what I’ve seen in some responses to the issues, asks you
read their <a href="https://github.com/stephenh/ts-proto/tree/main/integration">integration
tests</a> (possible,
but more difficult than parsing real code examples).</p>

<p>The author of <code class="language-plaintext highlighter-rouge">protobuf-ts</code> has written a <a href="https://github.com/timostamm/protobuf-ts/issues/89">summary of the differences between
these two libraries</a>,
although to be
honest, my currently visualized use case is basic enough that none of these will
likely matter to me. As someone newly figuring out the integrations in the
TypeScript protobuf world, I can recommend <code class="language-plaintext highlighter-rouge">protobuf-ts</code> solely due to its
documentation.</p>

<h3 id="client-side-grpc-client">Client-side GRPC Client</h3>

<p>There are two identically named repositories: <a href="https://github.com/grpc/grpc-web"><code class="language-plaintext highlighter-rouge">grpc/grpc-web</code></a> and
<a href="https://github.com/improbable-eng/grpc-web"><code class="language-plaintext highlighter-rouge">improbable-eng/grpc-web</code></a>.
The former is created by Google, and the second by another company. However, the
second one is in maintenance mode with the recommendation to use the official
one, which <a href="[https://github.com/improbable-eng/grpc-web](https://github.com/improbable-eng/grpc-web)">wasn’t even posted on the repo until I made a
PR</a>
(the maintainer had been warning people on the repo’s issues).</p>

<p>For technical reasons (Google it if you’re curious), using GRPC in the browser requires
a proxy. The <code class="language-plaintext highlighter-rouge">improbable-eng/grpc-web</code> library requires their own Go binary as a
proxy, which, upon realizing this, I immediately surmised that it would be
a nightmare to figure out how to deploy some random Go proxy if I
wanted to combine it with other things like AWS Lambda, etc. As expected, the 
<a href="https://github.com/improbable-eng/grpc-web/blob/master/go/grpcwebproxy/README.md">documentation for the proxy</a>
is scant. I didn’t think that the documentation for deploying
would be promising either, and as expected, there’s little guidance there,
except for a few GitHub issues.</p>

<p>In contrast, <code class="language-plaintext highlighter-rouge">grpc/grpc-web</code> suggests using <a href="https://www.envoyproxy.io/">Envoy</a>
as a proxy, which is quite well-known, well-maintained, and well-documented.
It has Docker support, and is, in general, more well-vetted.</p>

<p>I initially tried the following combination: <code class="language-plaintext highlighter-rouge">ts-proto</code> with <code class="language-plaintext highlighter-rouge">improbable-eng/grpc-web</code>. Both seemed popular. After getting a semi-working example using these two libraries, I then wanted to try the <code class="language-plaintext highlighter-rouge">ts-proto</code> and official <code class="language-plaintext highlighter-rouge">grpc/grpc-web</code> combinations (moving off the
<code class="language-plaintext highlighter-rouge">improbable-eng</code> due to the aforementioned proxy). From the <a href="https://github.com/stephenh/ts-proto#supported-options">supported options</a>
of <code class="language-plaintext highlighter-rouge">ts-proto</code>, it supports
<code class="language-plaintext highlighter-rouge">improbable-eng/grpc-web</code>, but not the official Google <code class="language-plaintext highlighter-rouge">grpc/grpc-web</code>.</p>

<p>It seems strange that <code class="language-plaintext highlighter-rouge">ts-proto</code> wouldn’t integrate with the official
Google library. Or maybe it does? But that’s the point — perhaps it does support it, but
<strong>the documentation isn’t there</strong>. I couldn’t find any code examples, any flag
documentation, any references, and I couldn’t figure out how to get the types to
work on my own by digging into the generated types (admittedly due to my own
lack of knowledge but hey, that’s the point of Hello World examples).</p>

<p>And if it is really true that <code class="language-plaintext highlighter-rouge">ts-proto</code> doesn’t work with the official,
Google-released version of <code class="language-plaintext highlighter-rouge">grpc/grpc-web</code>, then it suggests that the tool may
be outdated. Perhaps that version <code class="language-plaintext highlighter-rouge">grpc/grpc-web</code> didn’t exist then, but in any
case, the documentation should clarify this. The only reference I found to this
was <a href="https://github.com/stephenh/ts-proto/discussions/422">this answer from the maintainer</a>
about how the library predates gRPC, if I understood the post correctly.</p>

<h3 id="server-side">Server-side</h3>

<p>For writing a TypeScript Node server, there does exist decent documentation for
vanilla JavaScript. I just Googled some tutorials and tried to write a TypeScript
version of the <a href="https://grpc.io/docs/languages/node/basics/">official tutorial</a>.
Using both <code class="language-plaintext highlighter-rouge">ts-proto</code> and <code class="language-plaintext highlighter-rouge">protobuf-ts</code> here worked fine. Ultimately, I only ran into
problems with client-side web RPC typing. Nonetheless, you would want to use
the same generator for both the server and client side.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In conclusion, documentation. But also, if you are in a similar boat to me and
want to get started with a basic hello world, TypeScript gRPC web client and
server, I suggest using the two libraries I talked about.</p>

<p>Finally, I want to say that this post does not mean to detract from the work of
these open source contributors. Each of these libraries, at some point in time,
had their crucial role in the ecosystem.</p>
]]></content>
  </entry>
  
</feed>
